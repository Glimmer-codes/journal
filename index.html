<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Encrypted Cloud Journal</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#6366f1" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Journal" />

    <!-- Load Tailwind FIRST -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Load Supabase SECOND -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- ğŸ“„ Load jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- THEN your Tailwind config -->
    <script>
      tailwind.config = {
        darkMode: "class",
      };
    </script>
    <style>
      /* Your existing styles... */
      /* Custom scrollbar for aesthetics */
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-thumb {
        border-radius: 10px;
        background: #6b7280; /* gray-500 */
      }

      .dark ::-webkit-scrollbar-thumb {
        background: #9ca3af; /* gray-400 for dark mode */
      }

      /* Smooth transitions for everything */
      * {
        transition: background-color 0.3s ease, color 0.3s ease,
          border-color 0.3s ease;
      }

      /* Make sure the dark class applies to entire document */
      .dark {
        background-color: #121212;
        color: #e0e0e0;
      }

      /* Ensure modal backdrop covers entire screen */
      #editModal {
        transition: opacity 0.3s ease;
      }

      /* ğŸ“± Mobile Responsive Improvements */
      @media (max-width: 640px) {
        /* Make header more compact on mobile */
        header h1 {
          font-size: 1.5rem !important;
        }

        /* Stack header controls vertically if needed */
        header .flex.space-x-3 {
          flex-wrap: wrap;
          gap: 0.5rem;
        }

        /* Make navigation buttons stack on very small screens */
        nav.flex {
          flex-wrap: wrap;
          justify-content: center;
        }

        /* Adjust button padding for mobile */
        nav button {
          padding: 0.5rem 1rem !important;
          font-size: 0.875rem !important;
        }

        /* Make cards take full width with less padding */
        .card {
          padding: 1rem !important;
        }

        /* Ensure text inputs are readable */
        input,
        textarea,
        select {
          font-size: 16px !important; /* Prevents zoom on iOS */
        }
      }

      /* ğŸ·ï¸ Tag Badge Styles */
      .tag-badge {
        display: inline-flex;
        align-items: center;
        padding: 0.25rem 0.75rem;
        border-radius: 9999px;
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid transparent;
      }

      .tag-badge:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .tag-badge.dark-theme {
        border-color: rgba(255, 255, 255, 0.2);
      }

      .tag-fade-in {
        animation: tagFadeIn 0.4s ease-out forwards;
      }

      @keyframes tagFadeIn {
        from {
          opacity: 0;
          transform: translateY(-4px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Tag suggestions dropdown styling */
      #tagSuggestionsDropdown .suggestion-item {
        padding: 0.5rem 0.75rem;
        cursor: pointer;
        transition: background-color 0.15s ease;
      }

      #tagSuggestionsDropdown .suggestion-item:hover {
        background-color: #e5e7eb;
      }

      .dark #tagSuggestionsDropdown .suggestion-item:hover {
        background-color: #374151;
      }

      #tagSuggestionsDropdown .suggestion-item.selected {
        background-color: #e0e7ff;
      }

      .dark #tagSuggestionsDropdown .suggestion-item.selected {
        background-color: #4338ca;
      }

      /* âœ¨ Glow Button Effect */
      .glow-btn {
        transition: transform 0.15s ease, box-shadow 0.15s ease,
          filter 0.15s ease;
      }

      .glow-btn:hover {
        transform: scale(1.06);
        filter: brightness(1.1);
        box-shadow: 0 0 6px rgba(99, 102, 241, 0.6),
          0 0 14px rgba(99, 102, 241, 0.5), 0 0 24px rgba(99, 102, 241, 0.35);
      }

      .save-working {
        opacity: 1;
        color: #facc15; /* soft yellow */
      }

      .save-success {
        opacity: 1;
        color: #22c55e; /* soft green */
        text-shadow: 0 0 8px rgba(34, 197, 94, 0.6);
      }

      .save-hidden {
        opacity: 0;
      }

      .tag-active {
        box-shadow: 0 0 12px rgba(99, 102, 241, 0.8);
        background: linear-gradient(135deg, #6366f1, #a78bfa);
        color: white !important;
        transform: scale(1.05);
      }

      .tag-btn {
        padding: 6px 12px;
        border-radius: 10px;
        background: rgba(99, 102, 241, 0.12);
        border: 1px solid rgba(99, 102, 241, 0.4);
        color: #4f46e5;
        font-size: 0.8rem;
        cursor: pointer;
        transition: all 0.25s ease;
        opacity: 0.65;
      }

      .tag-btn:hover {
        opacity: 1;
        background: rgba(99, 102, 241, 0.22);
        box-shadow: 0 0 10px rgba(99, 102, 241, 0.45);
        transform: translateY(-1px);
      }

      .tag-btn {
        transition: box-shadow 0.2s ease, transform 0.2s ease;
      }

      .tag-btn:hover {
        box-shadow: 0 0 12px rgba(168, 85, 247, 0.9);
        transform: translateY(-1px);
      }

      /* Active tag glow */
      .tag-btn.active {
        box-shadow: 0 0 12px rgba(99, 102, 241, 0.9);
        background: #4338ca;
      }
    </style>
  </head>
  <body class="bg-gray-100 dark:bg-gray-900 min-h-screen p-4 md:p-8 font-sans">
    <div id="journal-app" class="max-w-4xl mx-auto">
      <!-- Header & Theme Switcher -->
      <header
        class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-3"
      >
        <h1
          id="appTitle"
          class="text-2xl sm:text-3xl font-extrabold text-indigo-600 dark:text-indigo-400"
        >
          Secure Cloud Journal
          <span
            id="appMode"
            class="text-xs sm:text-sm bg-green-500 text-white px-2 py-1 rounded"
            >CLOUD MODE</span
          >
        </h1>
        <div class="flex flex-wrap gap-2">
          <!-- ğŸ”Œ Connection Status Indicator -->
          <div
            id="connectionStatus"
            class="hidden px-2 sm:px-3 py-2 rounded-lg text-xs sm:text-sm font-medium"
          >
            <span id="connectionIcon">ğŸŸ¢</span>
            <span id="connectionText" class="hidden sm:inline">Online</span>
          </div>

          <!-- ğŸ”’ Privacy Mode Toggle -->
          <button
            id="privacyToggle"
            onclick="togglePrivacyMode()"
            class="glow-btn px-2 sm:px-3 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition hidden text-xs sm:text-sm"
            title="Toggle privacy mode"
          >
            ğŸ”’ <span class="hidden sm:inline">Privacy:</span>
            <span id="privacyStatus">ON</span>
          </button>
          <button
            id="themeToggle"
            class="glow-btn p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 transition"
          >
            <span id="themeIcon">â˜€ï¸</span>
          </button>
        </div>
      </header>

      <!-- Navigation Buttons (For separating pages) -->
      <nav
        id="mainNavigation"
        class="flex items-center justify-between mb-6 hidden"
      >
        <!-- Main Navigation Buttons -->
        <div class="flex gap-2 sm:gap-4 flex-wrap">
          <button
            id="viewEntriesBtn"
            class="glow-btn px-4 sm:px-6 py-2 rounded-lg font-semibold text-white bg-indigo-500 hover:bg-indigo-600 transition shadow-md text-sm sm:text-base"
          >
            ğŸ“ View Entries
          </button>
          <button
            id="newEntryBtn"
            class="glow-btn px-4 sm:px-6 py-2 rounded-lg font-semibold text-white bg-green-500 hover:bg-green-600 transition shadow-md text-sm sm:text-base"
          >
            âœ¨ New Entry
          </button>
        </div>

        <!-- More Menu (Desktop) / Hamburger (Mobile) -->
        <div class="relative">
          <button
            id="moreMenuBtn"
            class="glow-btn px-4 sm:px-6 py-2 rounded-lg font-semibold text-white bg-gray-600 hover:bg-gray-700 transition shadow-md text-sm sm:text-base"
            onclick="toggleMoreMenu()"
          >
            <span class="hidden sm:inline">More â‹®</span>
            <span class="sm:hidden">â˜°</span>
          </button>

          <!-- Dropdown Menu -->
          <div
            id="moreMenuDropdown"
            class="glow-btn hidden absolute right-0 mt-2 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-xl border border-gray-200 dark:border-gray-600 z-50"
          >
            <!-- ğŸŒ Language Switcher in Menu -->
            <div
              class="px-4 py-3 border-b border-gray-200 dark:border-gray-600"
            >
              <label class="text-xs text-gray-600 dark:text-gray-400 block mb-2"
                >ğŸŒ Language</label
              >
              <select
                id="languageSwitcher"
                onchange="changeUILanguage(this.value); closeMoreMenu();"
                class="w-full px-2 py-2 bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition text-xs cursor-pointer border border-gray-300 dark:border-gray-600"
              >
                <option value="en">ğŸ‡¬ğŸ‡§ English</option>
                <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
                <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
                <option value="ar">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
                <option value="hi">ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€</option>
                <option value="fr">ğŸ‡«ğŸ‡· FranÃ§ais</option>
              </select>
            </div>

            <button
              id="booksMenuBtn"
              class="glow-btn w-full text-left px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700 transition text-gray-800 dark:text-gray-200 flex items-center gap-2"
            >
              ğŸ“š <span>Books</span>
            </button>
            <button
              id="tagsMenuBtn"
              class="glow-btn w-full text-left px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700 transition text-gray-800 dark:text-gray-200 flex items-center gap-2"
            >
              ğŸ·ï¸ <span>Tags</span>
            </button>
            <button
              id="exportMenuBtn"
              class="glow-btn w-full text-left px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700 transition text-gray-800 dark:text-gray-200 flex items-center gap-2 border-t border-gray-200 dark:border-gray-600"
            >
              ğŸ“¤ <span>Export</span>
            </button>
            <button
              id="signOutBtn"
              class="glow-btn w-full text-left px-4 py-3 hover:bg-red-100 dark:hover:bg-red-900 transition text-red-600 dark:text-red-400 rounded-b-lg flex items-center gap-2 border-t border-gray-200 dark:border-gray-600"
            >
              ğŸšª <span>Sign Out / Switch Mode</span>
            </button>
          </div>
        </div>
      </nav>

      <!-- Status/Notification Message -->
      <div
        id="messageBox"
        class="hidden p-3 mb-4 rounded-lg bg-yellow-100 text-yellow-800 border-l-4 border-yellow-500 font-medium"
      ></div>

      <!-- MAIN VIEW 1: NEW ENTRY CARD -->
      <div
        id="newEntryView"
        class="card p-6 bg-white dark:bg-gray-800 rounded-xl shadow-xl"
      >
        <h2 class="text-2xl font-bold mb-4 text-gray-700 dark:text-gray-300">
          New Journal Entry
        </h2>
        <textarea
          id="journalInput"
          class="w-full h-40 p-4 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 resize-none text-gray-800 dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:placeholder-gray-400"
          placeholder="What's on your mind?"
          oninput="detectHashtagsInText()"
        ></textarea>

        <!-- ğŸŒ Entry Language Selector -->
        <div class="mt-3">
          <label
            for="entryLanguage"
            class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
          >
            ğŸŒ Entry Language
          </label>
          <select
            id="entryLanguage"
            class="px-3 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-800 dark:text-gray-200 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-sm"
          >
            <option value="en">ğŸ‡¬ğŸ‡§ English</option>
            <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
            <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
            <option value="ar">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
            <option value="hi">ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€</option>
            <option value="fr">ğŸ‡«ğŸ‡· FranÃ§ais</option>
          </select>
        </div>

        <!-- ğŸ“¸ PHASE 4: Image Upload Section -->
        <div class="mt-4">
          <input
            type="file"
            id="imageInput"
            accept="image/*"
            multiple
            class="hidden"
            onchange="handleImageSelect(event)"
          />
          <button
            onclick="document.getElementById('imageInput').click()"
            class="glow-btn px-3 py-2 bg-purple-600 text-white font-medium rounded-lg hover:bg-purple-700 transition duration-150 shadow-md flex items-center gap-2"
          >
            ğŸ“· Add Images
          </button>

          <button
            id="recordVoiceBtn"
            onclick="toggleVoiceRecording()"
            class="glow-btn px-3 py-2 bg-pink-600 text-white font-medium rounded-lg hover:bg-pink-700 transition duration-150 shadow-md flex items-center gap-2"
          >
            ğŸ¤ <span id="recordVoiceBtnText">Record Voice Note</span>
          </button>

          <button
            onclick="toggleTagButtons()"
            class="glow-btn px-3 py-1 text-sm"
          >
            ğŸ·ï¸ Tags
          </button>

          <!-- Voice Note Preview Area -->
          <div id="voiceNotePreview" class="mt-3 hidden">
            <div
              class="bg-pink-50 dark:bg-pink-900 border border-pink-300 dark:border-pink-700 rounded-lg p-2"
            >
              <div class="flex items-center justify-between mb-2">
                <span
                  class="text-sm font-medium text-pink-700 dark:text-pink-300"
                  >ğŸ¤ Voice Note Ready</span
                >
                <button
                  onclick="deleteVoiceNote()"
                  class="text-xs text-red-500 hover:text-red-700"
                >
                  ğŸ—‘ï¸ Delete
                </button>
              </div>
              <audio id="voiceNotePlayer" controls class="w-full h-8"></audio>
              <p class="text-xs text-pink-600 dark:text-pink-400 mt-1">
                Duration: <span id="voiceNoteDuration">0:00</span>
              </p>
            </div>
          </div>

          <!-- Image Preview Area -->
          <div
            id="imagePreviewContainer"
            class="mt-3 grid grid-cols-2 md:grid-cols-3 gap-3 hidden"
          >
            <!-- Image previews will appear here -->
          </div>
        </div>

        <!-- ğŸ·ï¸ PHASE 5: Tag Input Section -->
        <div class="mt-4">
          <label
            for="tagInput"
            class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
          >
            ğŸ·ï¸ Tags (optional)
          </label>
          <div class="relative">
            <input
              type="text"
              id="tagInput"
              placeholder="Add tags like #work, #personal, #ideas..."
              class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-gray-800 dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:placeholder-gray-400"
              oninput="updateTagPreview()"
              onkeydown="handleTagInputKeydown(event)"
            />
            <!-- Tag Suggestions Dropdown -->
            <div
              id="tagSuggestionsDropdown"
              class="absolute z-10 w-full mt-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg shadow-lg hidden max-h-48 overflow-y-auto"
            >
              <!-- Suggestions will appear here -->
            </div>
          </div>
          <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">
            Separate tags with commas or spaces. Type # to see suggestions!
          </p>

          <!-- Tag Preview Area -->
          <div
            id="tagPreviewContainer"
            class="mt-2 flex flex-wrap gap-2 hidden"
          >
            <!-- Tag badges will appear here as you type -->
          </div>
        </div>

        <div
          id="save-status"
          class="text-xs text-gray-500 dark:text-gray-400 mt-2 italic"
        >
          â³ Not saved yet
        </div>

        <div
          id="saveStatus"
          class="mt-2 text-sm opacity-0 transition-all duration-500"
        >
          ğŸ’¾ Ready
        </div>

        <div class="flex justify-between items-center mt-4">
          <button
            id="saveEntryBtn"
            onclick="saveEntry()"
            class="glow-btn px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition duration-150 shadow-md"
          >
            Securely Save Entry
          </button>
          <button
            id="changePasscodeBtn"
            onclick="changePasscode()"
            class="glow-btn px-4 py-2 bg-pink-600 text-white font-medium rounded-lg hover:bg-pink-700 transition duration-150 shadow-md"
          >
            Change Passcode
          </button>
        </div>
      </div>

      <!-- MAIN VIEW 2: ENTRIES LIST -->
      <div
        id="entriesListView"
        class="card p-6 bg-white dark:bg-gray-800 rounded-xl shadow-xl hidden"
      >
        <h2 class="text-2xl font-bold mb-4 text-gray-700 dark:text-gray-300">
          Journal History
        </h2>

        <!-- ğŸ” Search Bar -->
        <div class="mb-4 flex gap-2">
          <div class="relative flex-1">
            <input
              type="text"
              id="searchInput"
              placeholder="ğŸ” Search entries or type #tag..."
              class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 placeholder-gray-400"
              oninput="filterEntries()"
            />
          </div>
          <select
            id="languageFilter"
            class="px-3 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-800 dark:text-gray-200 rounded-lg text-sm"
            onchange="filterEntries()"
            title="Filter by language"
          >
            <option value="">All Languages</option>
            <option value="en">ğŸ‡¬ğŸ‡§ English</option>
            <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
            <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
            <option value="ar">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
            <option value="hi">ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€</option>
            <option value="fr">ğŸ‡«ğŸ‡· FranÃ§ais</option>
          </select>
          <button
            onclick="clearSearch()"
            class="glow-btn px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-500 transition"
            title="Clear search"
          >
            âœ•
          </button>
        </div>
        <div id="tagButtonWrapper" class="mb-4 hidden"></div>
        <div id="tagButtonBar" class="flex flex-wrap gap-2 mb-4"></div>

        <!-- ğŸ·ï¸ Active Tag Filters Display (Phase 5.3) -->
        <div id="activeTagFilters" class="mb-3 hidden">
          <div
            class="flex items-center justify-between bg-indigo-50 dark:bg-indigo-900 border border-indigo-200 dark:border-indigo-700 rounded-lg p-3"
          >
            <div class="flex items-center gap-2">
              <span
                class="text-sm font-semibold text-indigo-700 dark:text-indigo-300"
                >Active Filters:</span
              >
              <div id="activeTagBadges" class="flex flex-wrap gap-2">
                <!-- Active tag badges will appear here -->
              </div>
            </div>
            <button
              onclick="clearTagFilters()"
              class="glow-btn px-3 py-1 bg-indigo-600 text-white text-sm rounded-lg hover:bg-indigo-700 transition"
              title="Clear all tag filters"
              clearTagFilter();
              setActiveTagButton(null);
            >
              Clear Filters
            </button>
          </div>
        </div>

        <!-- Search Results Count -->
        <div
          id="searchResultsCount"
          class="text-sm text-gray-500 dark:text-gray-400 mb-2 hidden"
        ></div>

        <div id="entriesList" class="space-y-4 entry-list">
          <!-- Entries will be dynamically loaded here -->
        </div>
        <p id="noEntriesMessage" class="text-gray-500 italic mt-4 hidden">
          No entries found. Go to the "New Entry" view to start writing!
        </p>
      </div>

      <!-- MAIN VIEW 3: MANAGE TAGS -->
      <div
        id="manageTagsView"
        class="card p-6 bg-white dark:bg-gray-800 rounded-xl shadow-xl hidden"
      >
        <h2 class="text-2xl font-bold mb-4 text-gray-700 dark:text-gray-300">
          ğŸ·ï¸ Manage Tags
        </h2>

        <!-- Sort Options -->
        <div class="mb-4 flex gap-2 items-center">
          <label class="text-sm font-medium text-gray-700 dark:text-gray-300"
            >Sort by:</label
          >
          <button
            id="sortByName"
            class="glow-btn px-4 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition text-sm"
            onclick="sortTagsBy('name')"
          >
            Name
          </button>
          <button
            id="sortByCount"
            class="glow-btn px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-500 transition text-sm"
            onclick="sortTagsBy('count')"
          >
            Frequency
          </button>
        </div>

        <!-- Tags Grid -->
        <div
          id="tagsGrid"
          class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
        >
          <!-- Tags will be displayed here -->
        </div>

        <p id="noTagsMessage" class="text-gray-500 italic mt-4 hidden">
          No tags yet. Create some entries with tags to see them here!
        </p>
      </div>

      <!-- MAIN VIEW 4: BOOKS -->
      <div
        id="booksView"
        class="card p-6 bg-white dark:bg-gray-800 rounded-xl shadow-xl hidden"
      >
        <div class="flex justify-between items-center mb-6">
          <h2
            id="myBooksTitle"
            class="text-2xl font-bold text-gray-700 dark:text-gray-300"
          >
            ğŸ“š My Books
          </h2>
          <button
            id="addNewBookBtn"
            onclick="startNewBook()"
            class="glow-btn px-6 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 transition shadow-md font-semibold"
          >
            + Add New Book
          </button>
        </div>

        <!-- Books List -->
        <div id="booksList" class="space-y-4">
          <!-- Books will be displayed here -->
        </div>

        <p id="noBooksMessage" class="text-gray-500 italic mt-4 hidden">
          No books yet. Click "Add New Book" to start tracking your reading
          journey!
        </p>
      </div>

      <!-- BOOK DETAIL VIEW (shown when viewing/editing a specific book) -->
      <div
        id="bookDetailView"
        class="card p-6 bg-white dark:bg-gray-800 rounded-xl shadow-xl hidden"
      >
        <!-- Book detail will be rendered here dynamically -->
      </div>
    </div>

    <!-- MODAL for Editing Entry (Hidden by default) -->
    <div
      id="editModal"
      class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4"
    >
      <div
        class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-lg"
      >
        <h3 class="text-xl font-bold mb-4 text-gray-800 dark:text-gray-200">
          Edit Entry
          <span id="editModalId" class="text-indigo-500 text-sm"></span>
        </h3>
        <textarea
          id="editModalInput"
          class="w-full h-40 p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 resize-none text-gray-800 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        ></textarea>
        <div class="flex justify-end space-x-3 mt-4">
          <button
            onclick="closeEditModal()"
            class="glow-btn px-4 py-2 bg-gray-300 text-gray-800 font-medium rounded-lg hover:bg-gray-400 dark:bg-gray-700 dark:text-white dark:hover:bg-gray-600 transition"
          >
            Cancel
          </button>
          <button
            onclick="confirmEdit()"
            class="glow-btn px-4 py-2 bg-green-600 text-white font-medium rounded-lg hover:bg-green-700 transition"
          >
            Save Changes
          </button>
        </div>
      </div>
    </div>

    <!-- ğŸ†• CUSTOM PASSWORD MODAL (Phase 2) -->
    <div
      id="passwordModal"
      class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50"
    >
      <div
        class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-md"
      >
        <!-- Modal Title -->
        <h3
          id="passwordModalTitle"
          class="text-xl font-bold mb-2 text-gray-800 dark:text-gray-200"
        >
          ğŸ” Enter Passcode
        </h3>

        <!-- Modal Message (for warnings/instructions) -->
        <div
          id="passwordModalMessage"
          class="mb-4 text-sm text-gray-600 dark:text-gray-400 whitespace-pre-wrap hidden"
        ></div>

        <!-- Password Input with Show/Hide Toggle -->
        <div class="relative mb-4">
          <input
            type="password"
            id="passwordModalInput"
            placeholder="Enter your passcode..."
            class="w-full p-3 pr-12 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-gray-800 dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:placeholder-gray-400"
            autocomplete="off"
          />
          <!-- Eye Icon Button -->
          <button
            type="button"
            id="passwordToggleBtn"
            onclick="togglePasswordVisibility()"
            class="glow-btn absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition focus:outline-none"
            title="Show/Hide password"
          >
            <span id="passwordToggleIcon">ğŸ‘ï¸</span>
          </button>
        </div>

        <!-- Confirm Password Input (only shown when needed) -->
        <div id="passwordConfirmSection" class="relative mb-4 hidden">
          <input
            type="password"
            id="passwordModalConfirm"
            placeholder="Confirm your passcode..."
            class="w-full p-3 pr-12 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-gray-800 dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:placeholder-gray-400"
            autocomplete="off"
          />
          <button
            type="button"
            onclick="toggleConfirmPasswordVisibility()"
            class="glow-btn absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition focus:outline-none"
            title="Show/Hide password"
          >
            <span id="confirmPasswordToggleIcon">ğŸ‘ï¸</span>
          </button>
        </div>

        <!-- Buttons -->
        <div class="flex justify-end space-x-3">
          <button
            onclick="cancelPasswordModal()"
            class="glow-btn px-5 py-2 bg-gray-300 text-gray-800 font-medium rounded-lg hover:bg-gray-400 dark:bg-gray-700 dark:text-white dark:hover:bg-gray-600 transition"
          >
            Cancel
          </button>
          <button
            id="passwordModalSubmitBtn"
            onclick="submitPasswordModal()"
            class="glow-btn px-5 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 transition"
          >
            Continue
          </button>
        </div>
      </div>
    </div>

    <!-- ğŸ“š TEXT INPUT MODAL (for books and other text inputs) -->
    <div
      id="textInputModal"
      class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50"
    >
      <div
        class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-lg"
      >
        <h3
          id="textInputModalTitle"
          class="text-xl font-bold mb-2 text-gray-800 dark:text-gray-200"
        >
          Enter Text
        </h3>
        <p
          id="textInputModalMessage"
          class="text-sm text-gray-600 dark:text-gray-400 mb-4"
        ></p>
        <textarea
          id="textInputModalTextarea"
          class="w-full h-32 p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 resize-none text-gray-800 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
          placeholder="Type here..."
        ></textarea>
        <div class="flex justify-end space-x-3 mt-4">
          <button
            id="textInputModalCancelBtn"
            onclick="cancelTextInputModal()"
            class="glow-btn px-5 py-2 bg-gray-300 text-gray-800 font-medium rounded-lg hover:bg-gray-400 dark:bg-gray-700 dark:text-white dark:hover:bg-gray-600 transition"
          >
            Cancel
          </button>
          <button
            id="textInputModalSaveBtn"
            onclick="submitTextInputModal()"
            class="glow-btn px-5 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 transition"
          >
            Save
          </button>
        </div>
      </div>
    </div>

    <!-- ğŸ†• RECOVERY PHRASE MODAL (Phase 3) -->
    <div
      id="recoveryPhraseModal"
      class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50 overflow-y-auto"
    >
      <div
        class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-2xl my-8 max-h-[90vh] overflow-y-auto"
      >
        <!-- Header -->
        <div class="text-center mb-4">
          <h3
            class="text-xl md:text-2xl font-bold text-gray-800 dark:text-gray-200 mb-2"
          >
            ğŸ”‘ Your Recovery Phrase
          </h3>
          <p class="text-xs md:text-sm text-gray-600 dark:text-gray-400">
            Write these 12 words down in order. Keep them safe!
          </p>
        </div>

        <!-- Critical Warning -->
        <div
          class="bg-red-50 dark:bg-red-900 dark:bg-opacity-20 border-l-4 border-red-500 p-3 mb-4"
        >
          <p
            class="text-xs md:text-sm text-red-800 dark:text-red-200 font-semibold"
          >
            âš ï¸ CRITICAL:
          </p>
          <ul
            class="text-xs text-red-700 dark:text-red-300 mt-1 space-y-1 list-disc list-inside"
          >
            <li>These 12 words ARE your journal passcode</li>
            <li>Write them on paper and store somewhere safe</li>
            <li>Anyone with these words can access your journal</li>
            <li>If you lose them, your entries are PERMANENTLY lost</li>
          </ul>
        </div>

        <!-- Word Grid - Responsive -->
        <div
          id="recoveryPhraseWords"
          class="grid grid-cols-2 md:grid-cols-3 gap-2 mb-4"
        >
          <!-- Words will be inserted here dynamically -->
        </div>

        <!-- Confirmation Checkbox -->
        <div class="mb-4">
          <label class="flex items-start space-x-2 cursor-pointer">
            <input
              type="checkbox"
              id="recoveryPhraseConfirm"
              class="mt-1 w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
            />
            <span class="text-xs md:text-sm text-gray-700 dark:text-gray-300">
              I have written down these 12 words and stored them safely. I
              understand that losing them means losing access to my journal
              forever.
            </span>
          </label>
        </div>

        <!-- Buttons -->
        <div class="flex justify-end space-x-3">
          <button
            onclick="cancelRecoveryPhrase()"
            class="glow-btn px-4 py-2 text-sm bg-gray-300 text-gray-800 font-medium rounded-lg hover:bg-gray-400 dark:bg-gray-700 dark:text-white dark:hover:bg-gray-600 transition"
          >
            Cancel
          </button>
          <button
            id="confirmRecoveryPhraseBtn"
            onclick="confirmRecoveryPhrase()"
            class="glow=btn px-4 py-2 text-sm bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 transition disabled:opacity-50 disabled:cursor-not-allowed"
            disabled
          >
            I've Written It Down
          </button>
        </div>
      </div>
    </div>

    <script>
      // ========== CONSTANTS & GLOBALS ==========
      const MESSAGE_BOX = document.getElementById("messageBox");
      const NEW_ENTRY_VIEW = document.getElementById("newEntryView");
      const ENTRIES_LIST_VIEW = document.getElementById("entriesListView");
      const EDIT_MODAL = document.getElementById("editModal");
      const JOURNAL_INPUT = document.getElementById("journalInput");

      // Supabase setup
      const SUPABASE_URL = "https://euvvxdbbhffjvjqhgxko.supabase.co";
      const SUPABASE_ANON_KEY =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV1dnZ4ZGJiaGZmanZqcWhneGtvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA2MzU5MTMsImV4cCI6MjA3NjIxMTkxM30.8lFbI0svLQamdyBFMuGV8_0u88jOAAM4fAGWH2BG_II";
      const supabase = window.supabase.createClient(
        SUPABASE_URL,
        SUPABASE_ANON_KEY
      );

      let CURRENT_PASSWORD = null;
      let EDITING_ENTRY_ID = null;
      let CURRENT_USER = null;
      let IS_LOCAL_MODE = false;
      let COLLECTED_TAGS = [];
      let SHOW_TAG_BUTTONS = false; // manual toggle
      let PRIVACY_MODE = false; // your existing privacy system

      // ğŸ†• Password modal state
      let passwordModalResolver = null; // Stores the promise resolve function
      let passwordModalRequiresConfirm = false; // Whether to show confirm field

      // ğŸ†• PHASE 4: Image handling
      let CURRENT_IMAGES = []; // Array of {name, data, type} objects for current entry

      // ğŸ¤ Voice Note handling
      let CURRENT_VOICE_NOTE = null; // {data: base64Audio, duration: seconds}
      let mediaRecorder = null;
      let audioChunks = [];
      let isRecording = false;
      let recordingStartTime = null;

      // ğŸ·ï¸ PHASE 5: Tag handling
      let CURRENT_TAGS = []; // Array of tag strings for current entry
      let ALL_TAGS = new Set(); // Set of all unique tags ever used
      let ACTIVE_TAG_FILTERS = new Set(); // ğŸ·ï¸ Phase 5.3: Active tag filters
      let TAG_SORT_BY = "name"; // ğŸ·ï¸ Phase 5.4: Tag management sort preference (name or count)

      // ğŸ“š PHASE 6: Books tracking
      let ALL_BOOKS = []; // Array of book objects
      let CURRENT_BOOK_ID = null; // ID of book currently being viewed/edited

      // ğŸ”’ Privacy features
      let COLLAPSED_ENTRIES = new Set(); // Track which entries are collapsed
      let IMAGES_HIDDEN = true; // Default: hide images for privacy

      // ğŸ” Search functionality
      let ALL_ENTRIES = []; // Store all entries for filtering

      // ğŸŒ Language support
      let UI_LANGUAGE = "en"; // Current UI language
      let AVAILABLE_LANGUAGES = [
        { code: "en", name: "English", flag: "ğŸ‡¬ğŸ‡§", rtl: false },
        { code: "es", name: "EspaÃ±ol", flag: "ğŸ‡ªğŸ‡¸", rtl: false },
        { code: "zh", name: "ä¸­æ–‡", flag: "ğŸ‡¨ğŸ‡³", rtl: false },
        { code: "ar", name: "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", flag: "ğŸ‡¸ğŸ‡¦", rtl: true },
        { code: "hi", name: "à¤¹à¤¿à¤¨à¥à¤¦à¥€", flag: "ğŸ‡®ğŸ‡³", rtl: false },
        { code: "fr", name: "FranÃ§ais", flag: "ğŸ‡«ğŸ‡·", rtl: false },
      ];

      /**
       * Gets language information from language code
       * @param {string} code - Language code (e.g., 'en', 'es')
       * @returns {object} Language info object with name, flag, etc.
       */
      function getLanguageInfo(code) {
        return (
          AVAILABLE_LANGUAGES.find((lang) => lang.code === code) || {
            code: "en",
            name: "English",
            flag: "ğŸ‡¬ğŸ‡§",
            rtl: false,
          }
        );
      }

      // UI Translations
      const TRANSLATIONS = {
        en: {
          appTitle: "Secure Cloud Journal",
          localTitle: "Secure Local Journal",
          cloudModeLabel: "CLOUD MODE",
          localModeLabel: "LOCAL MODE",
          newEntry: "New Journal Entry",
          viewEntries: "View Entries",
          whatOnMind: "What's on your mind?",
          addImages: "Add Images",
          addCaption: "Add caption (optional)...",
          saveEntry: "Securely Save Entry",
          changePasscode: "Change Passcode",
          journalHistory: "Journal History",
          searchPlaceholder: "ğŸ” Search entries...",
          found: "Found",
          of: "of",
          entries: "entries",
          noEntries:
            'No entries found. Go to the "New Entry" view to start writing!',
          copy: "Copy",
          images: "Images",
          edit: "Edit",
          export: "Export",
          delete: "Delete",
          privacy: "Privacy",
          switchAccount: "Switch Account",
          switchMode: "Switch Mode",
          signIn: "Sign In",
          signUp: "Sign Up",
          useLocalMode: "Use Local Mode",
          entryLanguage: "Entry Language",
          collapse: "Collapse",
          clickToExpand: "Click to expand",
          clickToView: "Click to view",
          imageRemoved: "Image removed",
          entrySaved: "Entry securely saved!",
          entryDeleted: "Entry deleted successfully.",
          privacyOn: "Privacy mode ON - Images hidden, entries collapsed",
          privacyOff: "Privacy mode OFF - All visible",
          books: "Books",
          manageTags: "Tags",
          exportAll: "Export",
          languageChanged: "Language changed",
          language: "Language",
          more: "More",
          online: "Online",
          offline: "Offline",
          allLanguages: "All Languages",
          signOutSwitchMode: "Sign Out / Switch Mode",
          // Books section
          myBooks: "My Books",
          addNewBook: "Add New Book",
          noBooksYet:
            'No books yet. Click "Add New Book" to start tracking your reading journey!',
          bookTitle: "Book Title",
          bookAuthor: "Author",
          by: "by",
          reading: "Reading",
          finished: "Finished",
          started: "Started",
          yourRating: "Your Rating",
          beforeReading: "Before Reading",
          whileReading: "While Reading",
          afterReading: "After Reading",
          addNote: "Add Note",
          pageNumber: "Page Number",
          pageOptional:
            "What page are you on? (Leave blank if you don't want to track pages)",
          addNotePrompt: "Add a quote, passage, or your thoughts:",
          page: "Page",
          completeJourney: "Complete Reading Journey",
          beforeReadingPrompt:
            "What are your thoughts BEFORE reading?\n(What drew you to this book? Any expectations or preconceptions?)",
          afterReadingPrompt:
            "Your thoughts AFTER reading:\n(How do you feel now? Did anything change in your perspective?)",
          beforeReadingHint:
            "What draws you to this book? Any expectations or preconceptions?",
          whileReadingHint:
            "Add quotes, passages, or thoughts as you read. Include page numbers to remember where you found them!",
          afterReadingHint: "How do you feel now? Did your perspective shift?",
          myBooks: "My Books",
          by: "by",
          reading: "Reading",
          finished: "Finished",
          started: "Started",
          typeHere: "Type here...",
          cancel: "Cancel",
          save: "Save",
          entry: "entry",
          // Tags section
          allTags: "All Tags",
          times: "times",
          rename: "Rename",
          renameTag: "Rename Tag",
          deleteTag: "Delete Tag",
          sortBy: "Sort by:",
          sortByName: "Name",
          sortByUsage: "Usage",
          frequency: "Frequency",
        },
        es: {
          appTitle: "Diario Seguro en la Nube",
          localTitle: "Diario Local Seguro",
          cloudModeLabel: "MODO NUBE",
          localModeLabel: "MODO LOCAL",
          newEntry: "Nueva Entrada",
          viewEntries: "Ver Entradas",
          whatOnMind: "Â¿QuÃ© piensas?",
          addImages: "Agregar ImÃ¡genes",
          addCaption: "Agregar descripciÃ³n (opcional)...",
          saveEntry: "Guardar Entrada",
          changePasscode: "Cambiar ContraseÃ±a",
          journalHistory: "Historial del Diario",
          searchPlaceholder: "ğŸ” Buscar entradas...",
          found: "Encontrado",
          of: "de",
          entries: "entradas",
          noEntries:
            'Â¡No se encontraron entradas. Ve a "Nueva Entrada" para comenzar!',
          copy: "Copiar",
          images: "ImÃ¡genes",
          edit: "Editar",
          export: "Exportar",
          delete: "Eliminar",
          privacy: "Privacidad",
          switchAccount: "Cambiar Cuenta",
          switchMode: "Cambiar Modo",
          signIn: "Iniciar SesiÃ³n",
          signUp: "Registrarse",
          useLocalMode: "Usar Modo Local",
          entryLanguage: "Idioma de Entrada",
          collapse: "Contraer",
          clickToExpand: "Clic para expandir",
          clickToView: "Clic para ver",
          imageRemoved: "Imagen eliminada",
          entrySaved: "Â¡Entrada guardada!",
          entryDeleted: "Entrada eliminada.",
          privacyOn: "Modo privacidad ACTIVADO",
          privacyOff: "Modo privacidad DESACTIVADO",
          books: "Libros",
          manageTags: "Etiquetas",
          exportAll: "Exportar",
          languageChanged: "Idioma cambiado",
          language: "Idioma",
          more: "MÃ¡s",
          online: "En lÃ­nea",
          offline: "Sin conexiÃ³n",
          allLanguages: "Todos los idiomas",
          signOutSwitchMode: "Cerrar SesiÃ³n / Cambiar Modo",
          // Books section
          myBooks: "Mis Libros",
          addNewBook: "Agregar Nuevo Libro",
          noBooksYet:
            'No hay libros todavÃ­a. Haz clic en "Agregar Nuevo Libro" para comenzar tu viaje de lectura!',
          bookTitle: "TÃ­tulo del Libro",
          bookAuthor: "Autor",
          by: "por",
          reading: "Leyendo",
          finished: "Terminado",
          started: "Comenzado",
          yourRating: "Tu CalificaciÃ³n",
          beforeReading: "Antes de Leer",
          whileReading: "Mientras Lees",
          afterReading: "DespuÃ©s de Leer",
          addNote: "Agregar Nota",
          pageNumber: "NÃºmero de PÃ¡gina",
          pageOptional:
            "Â¿En quÃ© pÃ¡gina estÃ¡s? (DÃ©jalo en blanco si no quieres rastrear pÃ¡ginas)",
          addNotePrompt: "Agrega una cita, pasaje o tus pensamientos:",
          page: "PÃ¡gina",
          completeJourney: "Viaje de Lectura Completo",
          beforeReadingPrompt:
            "Â¿CuÃ¡les son tus pensamientos ANTES de leer?\n(Â¿QuÃ© te atrajo de este libro? Â¿Tienes alguna expectativa?)",
          afterReadingPrompt:
            "Tus pensamientos DESPUÃ‰S de leer:\n(Â¿CÃ³mo te sientes ahora? Â¿CambiÃ³ tu perspectiva?)",
          beforeReadingHint:
            "Â¿QuÃ© te atrae de este libro? Â¿Tienes alguna expectativa?",
          whileReadingHint:
            "Agrega citas, pasajes o pensamientos mientras lees. Â¡Incluye nÃºmeros de pÃ¡gina!",
          afterReadingHint: "Â¿CÃ³mo te sientes ahora? Â¿CambiÃ³ tu perspectiva?",
          by: "por",
          reading: "Leyendo",
          finished: "Terminado",
          started: "Comenzado",
          typeHere: "Escribe aquÃ­...",
          cancel: "Cancelar",
          save: "Guardar",
          entry: "entrada",
          // Tags section
          allTags: "Todas las Etiquetas",
          times: "veces",
          rename: "Renombrar",
          renameTag: "Renombrar Etiqueta",
          deleteTag: "Eliminar Etiqueta",
          sortBy: "Ordenar por:",
          sortByName: "Nombre",
          sortByUsage: "Uso",
          frequency: "Frecuencia",
        },
        zh: {
          appTitle: "å®‰å…¨äº‘æ—¥è®°",
          localTitle: "å®‰å…¨æœ¬åœ°æ—¥è®°",
          cloudModeLabel: "äº‘æ¨¡å¼",
          localModeLabel: "æœ¬åœ°æ¨¡å¼",
          newEntry: "æ–°æ—¥è®°",
          viewEntries: "æŸ¥çœ‹æ—¥è®°",
          whatOnMind: "ä½ åœ¨æƒ³ä»€ä¹ˆï¼Ÿ",
          addImages: "æ·»åŠ å›¾ç‰‡",
          addCaption: "æ·»åŠ è¯´æ˜ï¼ˆå¯é€‰ï¼‰...",
          saveEntry: "ä¿å­˜æ—¥è®°",
          changePasscode: "æ›´æ”¹å¯†ç ",
          journalHistory: "æ—¥è®°å†å²",
          searchPlaceholder: "ğŸ” æœç´¢æ—¥è®°...",
          found: "æ‰¾åˆ°",
          of: "å…±",
          entries: "æ¡",
          noEntries: 'æ²¡æœ‰æ‰¾åˆ°æ—¥è®°ã€‚å»"æ–°æ—¥è®°"å¼€å§‹å†™ä½œï¼',
          copy: "å¤åˆ¶",
          images: "å›¾ç‰‡",
          edit: "ç¼–è¾‘",
          export: "å¯¼å‡º",
          delete: "åˆ é™¤",
          privacy: "éšç§",
          switchAccount: "åˆ‡æ¢è´¦æˆ·",
          switchMode: "åˆ‡æ¢æ¨¡å¼",
          signIn: "ç™»å½•",
          signUp: "æ³¨å†Œ",
          useLocalMode: "ä½¿ç”¨æœ¬åœ°æ¨¡å¼",
          entryLanguage: "æ—¥è®°è¯­è¨€",
          collapse: "æŠ˜å ",
          clickToExpand: "ç‚¹å‡»å±•å¼€",
          clickToView: "ç‚¹å‡»æŸ¥çœ‹",
          imageRemoved: "å›¾ç‰‡å·²åˆ é™¤",
          entrySaved: "æ—¥è®°å·²ä¿å­˜ï¼",
          entryDeleted: "æ—¥è®°å·²åˆ é™¤",
          privacyOn: "éšç§æ¨¡å¼å·²å¼€å¯",
          privacyOff: "éšç§æ¨¡å¼å·²å…³é—­",
          books: "å›¾ä¹¦",
          manageTags: "æ ‡ç­¾",
          exportAll: "å¯¼å‡º",
          languageChanged: "è¯­è¨€å·²æ›´æ”¹",
          language: "è¯­è¨€",
          more: "æ›´å¤š",
          online: "åœ¨çº¿",
          offline: "ç¦»çº¿",
          allLanguages: "æ‰€æœ‰è¯­è¨€",
          signOutSwitchMode: "é€€å‡º / åˆ‡æ¢æ¨¡å¼",
          // Books section
          addNewBook: "æ·»åŠ æ–°ä¹¦",
          noBooksYet: 'è¿˜æ²¡æœ‰ä¹¦ã€‚ç‚¹å‡»"æ·»åŠ æ–°ä¹¦"å¼€å§‹æ‚¨çš„é˜…è¯»ä¹‹æ—…ï¼',
          bookTitle: "ä¹¦å",
          bookAuthor: "ä½œè€…",
          yourRating: "æ‚¨çš„è¯„åˆ†",
          beforeReading: "é˜…è¯»å‰",
          whileReading: "é˜…è¯»ä¸­",
          afterReading: "é˜…è¯»å",
          addNote: "æ·»åŠ ç¬”è®°",
          pageNumber: "é¡µç ",
          pageOptional: "æ‚¨åœ¨ç¬¬å‡ é¡µï¼Ÿ(å¦‚æœä¸æƒ³è¿½è¸ªé¡µç å¯ç•™ç©º)",
          addNotePrompt: "æ·»åŠ å¼•ç”¨ã€æ®µè½æˆ–æ‚¨çš„æƒ³æ³•ï¼š",
          page: "é¡µ",
          completeJourney: "å®Œæ•´é˜…è¯»ä¹‹æ—…",
          beforeReadingPrompt:
            "é˜…è¯»å‰çš„æƒ³æ³•ï¼Ÿ\n(è¿™æœ¬ä¹¦å¸å¼•æ‚¨çš„åœ°æ–¹ï¼Ÿæœ‰ä»€ä¹ˆæœŸå¾…å—ï¼Ÿ)",
          afterReadingPrompt:
            "é˜…è¯»åçš„æƒ³æ³•ï¼š\n(ç°åœ¨æ„Ÿè§‰å¦‚ä½•ï¼Ÿæ‚¨çš„è§‚ç‚¹æ”¹å˜äº†å—ï¼Ÿ)",
          beforeReadingHint: "è¿™æœ¬ä¹¦å¸å¼•æ‚¨çš„åœ°æ–¹ï¼Ÿæœ‰ä»€ä¹ˆæœŸå¾…å—ï¼Ÿ",
          whileReadingHint: "é˜…è¯»æ—¶æ·»åŠ å¼•ç”¨ã€æ®µè½æˆ–æƒ³æ³•ã€‚åŒ…æ‹¬é¡µç ä»¥è®°ä½å®ƒä»¬ï¼",
          afterReadingHint: "ç°åœ¨æ„Ÿè§‰å¦‚ä½•ï¼Ÿæ‚¨çš„è§‚ç‚¹æ”¹å˜äº†å—ï¼Ÿ",
          typeHere: "åœ¨è¿™é‡Œè¾“å…¥...",
          cancel: "å–æ¶ˆ",
          save: "ä¿å­˜",
          entry: "æ¡ç›®",
          myBooks: "æˆ‘çš„ä¹¦ç±",
          by: "ä½œè€…",
          reading: "é˜…è¯»ä¸­",
          finished: "å·²å®Œæˆ",
          started: "å¼€å§‹äº",
          // Tags section
          allTags: "æ‰€æœ‰æ ‡ç­¾",
          times: "æ¬¡",
          rename: "é‡å‘½å",
          renameTag: "é‡å‘½åæ ‡ç­¾",
          deleteTag: "åˆ é™¤æ ‡ç­¾",
          sortBy: "æ’åºï¼š",
          sortByName: "åç§°",
          sortByUsage: "ä½¿ç”¨æ¬¡æ•°",
          frequency: "é¢‘ç‡",
        },
        ar: {
          appTitle: "ÙŠÙˆÙ…ÙŠØ§Øª Ø¢Ù…Ù†Ø© Ø³Ø­Ø§Ø¨ÙŠØ©",
          localTitle: "ÙŠÙˆÙ…ÙŠØ§Øª Ù…Ø­Ù„ÙŠØ© Ø¢Ù…Ù†Ø©",
          cloudModeLabel: "ÙˆØ¶Ø¹ Ø§Ù„Ø³Ø­Ø§Ø¨Ø©",
          localModeLabel: "Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø­Ù„ÙŠ",
          newEntry: "Ù…Ø¯Ø®Ù„ Ø¬Ø¯ÙŠØ¯",
          viewEntries: "Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª",
          whatOnMind: "Ù…Ø§ Ø§Ù„Ø°ÙŠ ØªÙÙƒØ± ÙÙŠÙ‡ØŸ",
          addImages: "Ø¥Ø¶Ø§ÙØ© ØµÙˆØ±",
          addCaption: "Ø¥Ø¶Ø§ÙØ© ÙˆØµÙ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)...",
          saveEntry: "Ø­ÙØ¸ Ø§Ù„Ù…Ø¯Ø®Ù„",
          changePasscode: "ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±",
          journalHistory: "Ø³Ø¬Ù„ Ø§Ù„ÙŠÙˆÙ…ÙŠØ§Øª",
          searchPlaceholder: "ğŸ” Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª...",
          found: "ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰",
          of: "Ù…Ù†",
          entries: "Ù…Ø¯Ø®Ù„Ø§Øª",
          noEntries:
            'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¯Ø®Ù„Ø§Øª. Ø§Ù†ØªÙ‚Ù„ Ø¥Ù„Ù‰ "Ù…Ø¯Ø®Ù„ Ø¬Ø¯ÙŠØ¯" Ù„Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØªØ§Ø¨Ø©!',
          copy: "Ù†Ø³Ø®",
          images: "ØµÙˆØ±",
          edit: "ØªØ¹Ø¯ÙŠÙ„",
          export: "ØªØµØ¯ÙŠØ±",
          delete: "Ø­Ø°Ù",
          privacy: "Ø®ØµÙˆØµÙŠØ©",
          switchAccount: "ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨",
          switchMode: "ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹",
          signIn: "ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
          signUp: "Ø§Ù„ØªØ³Ø¬ÙŠÙ„",
          useLocalMode: "Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø­Ù„ÙŠ",
          entryLanguage: "Ù„ØºØ© Ø§Ù„Ù…Ø¯Ø®Ù„",
          collapse: "Ø·ÙŠ",
          clickToExpand: "Ø§Ù†Ù‚Ø± Ù„Ù„ØªÙˆØ³ÙŠØ¹",
          clickToView: "Ø§Ù†Ù‚Ø± Ù„Ù„Ø¹Ø±Ø¶",
          imageRemoved: "ØªÙ… Ø­Ø°Ù Ø§Ù„ØµÙˆØ±Ø©",
          entrySaved: "ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø¯Ø®Ù„!",
          entryDeleted: "ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø¯Ø®Ù„",
          privacyOn: "ÙˆØ¶Ø¹ Ø§Ù„Ø®ØµÙˆØµÙŠØ© Ù‚ÙŠØ¯ Ø§Ù„ØªØ´ØºÙŠÙ„",
          privacyOff: "ÙˆØ¶Ø¹ Ø§Ù„Ø®ØµÙˆØµÙŠØ© Ù…ØªÙˆÙ‚Ù",
          books: "Ø§Ù„ÙƒØªØ¨",
          manageTags: "Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª",
          exportAll: "ØªØµØ¯ÙŠØ±",
          languageChanged: "ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ©",
          language: "Ø§Ù„Ù„ØºØ©",
          more: "Ø§Ù„Ù…Ø²ÙŠØ¯",
          online: "Ù…ØªØµÙ„",
          offline: "ØºÙŠØ± Ù…ØªØµÙ„",
          allLanguages: "Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù„ØºØ§Øª",
          signOutSwitchMode: "ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ / ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹",
          // Books section
          addNewBook: "Ø¥Ø¶Ø§ÙØ© ÙƒØªØ§Ø¨ Ø¬Ø¯ÙŠØ¯",
          noBooksYet:
            'Ù„Ø§ ØªÙˆØ¬Ø¯ ÙƒØªØ¨ Ø¨Ø¹Ø¯. Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ "Ø¥Ø¶Ø§ÙØ© ÙƒØªØ§Ø¨ Ø¬Ø¯ÙŠØ¯" Ù„Ø¨Ø¯Ø¡ Ø±Ø­Ù„Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©!',
          bookTitle: "Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ÙƒØªØ§Ø¨",
          bookAuthor: "Ø§Ù„Ù…Ø¤Ù„Ù",
          yourRating: "ØªÙ‚ÙŠÙŠÙ…Ùƒ",
          beforeReading: "Ù‚Ø¨Ù„ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©",
          whileReading: "Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©",
          afterReading: "Ø¨Ø¹Ø¯ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©",
          addNote: "Ø¥Ø¶Ø§ÙØ© Ù…Ù„Ø§Ø­Ø¸Ø©",
          pageNumber: "Ø±Ù‚Ù… Ø§Ù„ØµÙØ­Ø©",
          pageOptional:
            "ÙÙŠ Ø£ÙŠ ØµÙØ­Ø© Ø£Ù†ØªØŸ (Ø§ØªØ±ÙƒÙ‡ ÙØ§Ø±ØºÙ‹Ø§ Ø¥Ø°Ø§ ÙƒÙ†Øª Ù„Ø§ ØªØ±ÙŠØ¯ ØªØªØ¨Ø¹ Ø§Ù„ØµÙØ­Ø§Øª)",
          addNotePrompt: "Ø£Ø¶Ù Ø§Ù‚ØªØ¨Ø§Ø³Ù‹Ø§ Ø£Ùˆ Ù…Ù‚Ø·Ø¹Ù‹Ø§ Ø£Ùˆ Ø£ÙÙƒØ§Ø±Ùƒ:",
          page: "ØµÙØ­Ø©",
          completeJourney: "Ø±Ø­Ù„Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©",
          beforeReadingPrompt:
            "Ù…Ø§ Ù‡ÙŠ Ø£ÙÙƒØ§Ø±Ùƒ Ù‚Ø¨Ù„ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©ØŸ\n(Ù…Ø§ Ø§Ù„Ø°ÙŠ Ø¬Ø°Ø¨Ùƒ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙƒØªØ§Ø¨ØŸ Ù‡Ù„ Ù„Ø¯ÙŠÙƒ ØªÙˆÙ‚Ø¹Ø§ØªØŸ)",
          afterReadingPrompt:
            "Ø£ÙÙƒØ§Ø±Ùƒ Ø¨Ø¹Ø¯ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©:\n(ÙƒÙŠÙ ØªØ´Ø¹Ø± Ø§Ù„Ø¢Ù†ØŸ Ù‡Ù„ ØªØºÙŠØ± Ù…Ù†Ø¸ÙˆØ±ÙƒØŸ)",
          beforeReadingHint: "Ù…Ø§ Ø§Ù„Ø°ÙŠ Ø¬Ø°Ø¨Ùƒ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙƒØªØ§Ø¨ØŸ Ù‡Ù„ Ù„Ø¯ÙŠÙƒ ØªÙˆÙ‚Ø¹Ø§ØªØŸ",
          whileReadingHint:
            "Ø£Ø¶Ù Ø§Ù‚ØªØ¨Ø§Ø³Ø§Øª Ø£Ùˆ Ù…Ù‚Ø§Ø·Ø¹ Ø£Ùˆ Ø£ÙÙƒØ§Ø± Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©. Ù‚Ù… Ø¨ØªØ¶Ù…ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø§Ù„ØµÙØ­Ø§Øª!",
          afterReadingHint: "ÙƒÙŠÙ ØªØ´Ø¹Ø± Ø§Ù„Ø¢Ù†ØŸ Ù‡Ù„ ØªØºÙŠØ± Ù…Ù†Ø¸ÙˆØ±ÙƒØŸ",
          typeHere: "Ø§ÙƒØªØ¨ Ù‡Ù†Ø§...",
          cancel: "Ø¥Ù„ØºØ§Ø¡",
          save: "Ø­ÙØ¸",
          entry: "Ø¥Ø¯Ø®Ø§Ù„",
          myBooks: "ÙƒØªØ¨ÙŠ",
          by: "Ø¨ÙˆØ§Ø³Ø·Ø©",
          reading: "Ù‚Ø±Ø§Ø¡Ø©",
          finished: "Ù…ÙƒØªÙ…Ù„",
          started: "Ø¨Ø¯Ø£",
          // Tags section
          allTags: "Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª",
          times: "Ù…Ø±Ø§Øª",
          rename: "Ø¥Ø¹Ø§Ø¯Ø© ØªØ³Ù…ÙŠØ©",
          renameTag: "Ø¥Ø¹Ø§Ø¯Ø© ØªØ³Ù…ÙŠØ© Ø§Ù„Ø¹Ù„Ø§Ù…Ø©",
          deleteTag: "Ø­Ø°Ù Ø§Ù„Ø¹Ù„Ø§Ù…Ø©",
          sortBy: "ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨:",
          sortByName: "Ø§Ù„Ø§Ø³Ù…",
          sortByUsage: "Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…",
          frequency: "Ø§Ù„ØªÙƒØ±Ø§Ø±",
        },
        hi: {
          appTitle: "à¤¸à¥à¤°à¤•à¥à¤·à¤¿à¤¤ à¤•à¥à¤²à¤¾à¤‰à¤¡ à¤¡à¤¾à¤¯à¤°à¥€",
          localTitle: "à¤¸à¥à¤°à¤•à¥à¤·à¤¿à¤¤ à¤¸à¥à¤¥à¤¾à¤¨à¥€à¤¯ à¤¡à¤¾à¤¯à¤°à¥€",
          cloudModeLabel: "à¤•à¥à¤²à¤¾à¤‰à¤¡ à¤®à¥‹à¤¡",
          localModeLabel: "à¤¸à¥à¤¥à¤¾à¤¨à¥€à¤¯ à¤®à¥‹à¤¡",
          newEntry: "à¤¨à¤ˆ à¤ªà¥à¤°à¤µà¤¿à¤·à¥à¤Ÿà¤¿",
          viewEntries: "à¤ªà¥à¤°à¤µà¤¿à¤·à¥à¤Ÿà¤¿à¤¯à¤¾à¤ à¤¦à¥‡à¤–à¥‡à¤‚",
          whatOnMind: "à¤†à¤ª à¤•à¥à¤¯à¤¾ à¤¸à¥‹à¤š à¤°à¤¹à¥‡ à¤¹à¥ˆà¤‚?",
          addImages: "à¤šà¤¿à¤¤à¥à¤° à¤œà¥‹à¤¡à¤¼à¥‡à¤‚",
          addCaption: "à¤µà¤¿à¤µà¤°à¤£ à¤œà¥‹à¤¡à¤¼à¥‡à¤‚ (à¤µà¥ˆà¤•à¤²à¥à¤ªà¤¿à¤•)...",
          saveEntry: "à¤ªà¥à¤°à¤µà¤¿à¤·à¥à¤Ÿà¤¿ à¤¸à¤¹à¥‡à¤œà¥‡à¤‚",
          changePasscode: "à¤ªà¤¾à¤¸à¤•à¥‹à¤¡ à¤¬à¤¦à¤²à¥‡à¤‚",
          journalHistory: "à¤¡à¤¾à¤¯à¤°à¥€ à¤‡à¤¤à¤¿à¤¹à¤¾à¤¸",
          searchPlaceholder: "ğŸ” à¤ªà¥à¤°à¤µà¤¿à¤·à¥à¤Ÿà¤¿à¤¯à¤¾à¤ à¤–à¥‹à¤œà¥‡à¤‚...",
          found: "à¤®à¤¿à¤²à¤¾",
          of: "à¤®à¥‡à¤‚ à¤¸à¥‡",
          entries: "à¤ªà¥à¤°à¤µà¤¿à¤·à¥à¤Ÿà¤¿à¤¯à¤¾à¤",
          noEntries:
            'à¤•à¥‹à¤ˆ à¤ªà¥à¤°à¤µà¤¿à¤·à¥à¤Ÿà¤¿ à¤¨à¤¹à¥€à¤‚ à¤®à¤¿à¤²à¥€à¥¤ à¤²à¤¿à¤–à¤¨à¤¾ à¤¶à¥à¤°à¥‚ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ "à¤¨à¤ˆ à¤ªà¥à¤°à¤µà¤¿à¤·à¥à¤Ÿà¤¿" à¤ªà¤° à¤œà¤¾à¤à¤‚!',
          copy: "à¤•à¥‰à¤ªà¥€",
          images: "à¤šà¤¿à¤¤à¥à¤°",
          edit: "à¤¸à¤‚à¤ªà¤¾à¤¦à¤¿à¤¤ à¤•à¤°à¥‡à¤‚",
          export: "à¤¨à¤¿à¤°à¥à¤¯à¤¾à¤¤",
          delete: "à¤¹à¤Ÿà¤¾à¤à¤‚",
          privacy: "à¤—à¥‹à¤ªà¤¨à¥€à¤¯à¤¤à¤¾",
          switchAccount: "à¤–à¤¾à¤¤à¤¾ à¤¬à¤¦à¤²à¥‡à¤‚",
          switchMode: "à¤®à¥‹à¤¡ à¤¬à¤¦à¤²à¥‡à¤‚",
          signIn: "à¤¸à¤¾à¤‡à¤¨ à¤‡à¤¨ à¤•à¤°à¥‡à¤‚",
          signUp: "à¤¸à¤¾à¤‡à¤¨ à¤…à¤ª à¤•à¤°à¥‡à¤‚",
          useLocalMode: "à¤¸à¥à¤¥à¤¾à¤¨à¥€à¤¯ à¤®à¥‹à¤¡ à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¥‡à¤‚",
          entryLanguage: "à¤ªà¥à¤°à¤µà¤¿à¤·à¥à¤Ÿà¤¿ à¤­à¤¾à¤·à¤¾",
          collapse: "à¤¸à¤‚à¤•à¥à¤·à¤¿à¤ªà¥à¤¤ à¤•à¤°à¥‡à¤‚",
          clickToExpand: "à¤µà¤¿à¤¸à¥à¤¤à¤¾à¤° à¤•à¥‡ à¤²à¤¿à¤ à¤•à¥à¤²à¤¿à¤• à¤•à¤°à¥‡à¤‚",
          clickToView: "à¤¦à¥‡à¤–à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤•à¥à¤²à¤¿à¤• à¤•à¤°à¥‡à¤‚",
          imageRemoved: "à¤šà¤¿à¤¤à¥à¤° à¤¹à¤Ÿà¤¾à¤¯à¤¾ à¤—à¤¯à¤¾",
          entrySaved: "à¤ªà¥à¤°à¤µà¤¿à¤·à¥à¤Ÿà¤¿ à¤¸à¤¹à¥‡à¤œà¥€ à¤—à¤ˆ!",
          entryDeleted: "à¤ªà¥à¤°à¤µà¤¿à¤·à¥à¤Ÿà¤¿ à¤¹à¤Ÿà¤¾ à¤¦à¥€ à¤—à¤ˆ",
          privacyOn: "à¤—à¥‹à¤ªà¤¨à¥€à¤¯à¤¤à¤¾ à¤®à¥‹à¤¡ à¤šà¤¾à¤²à¥‚",
          privacyOff: "à¤—à¥‹à¤ªà¤¨à¥€à¤¯à¤¤à¤¾ à¤®à¥‹à¤¡ à¤¬à¤‚à¤¦",
          books: "à¤ªà¥à¤¸à¥à¤¤à¤•à¥‡à¤‚",
          manageTags: "à¤Ÿà¥ˆà¤—",
          exportAll: "à¤¨à¤¿à¤°à¥à¤¯à¤¾à¤¤",
          languageChanged: "à¤­à¤¾à¤·à¤¾ à¤¬à¤¦à¤²à¥€ à¤—à¤ˆ",
          language: "à¤­à¤¾à¤·à¤¾",
          more: "à¤…à¤§à¤¿à¤•",
          online: "à¤‘à¤¨à¤²à¤¾à¤‡à¤¨",
          offline: "à¤‘à¤«à¤¼à¤²à¤¾à¤‡à¤¨",
          allLanguages: "à¤¸à¤­à¥€ à¤­à¤¾à¤·à¤¾à¤à¤",
          signOutSwitchMode: "à¤¸à¤¾à¤‡à¤¨ à¤†à¤‰à¤Ÿ / à¤®à¥‹à¤¡ à¤¬à¤¦à¤²à¥‡à¤‚",
          // Books section
          addNewBook: "à¤¨à¤ˆ à¤ªà¥à¤¸à¥à¤¤à¤• à¤œà¥‹à¤¡à¤¼à¥‡à¤‚",
          noBooksYet:
            'à¤…à¤­à¥€ à¤¤à¤• à¤•à¥‹à¤ˆ à¤ªà¥à¤¸à¥à¤¤à¤• à¤¨à¤¹à¥€à¤‚ à¤¹à¥ˆà¥¤ à¤…à¤ªà¤¨à¥€ à¤ªà¤ à¤¨ à¤¯à¤¾à¤¤à¥à¤°à¤¾ à¤¶à¥à¤°à¥‚ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ "à¤¨à¤ˆ à¤ªà¥à¤¸à¥à¤¤à¤• à¤œà¥‹à¤¡à¤¼à¥‡à¤‚" à¤ªà¤° à¤•à¥à¤²à¤¿à¤• à¤•à¤°à¥‡à¤‚!',
          bookTitle: "à¤ªà¥à¤¸à¥à¤¤à¤• à¤•à¤¾ à¤¶à¥€à¤°à¥à¤·à¤•",
          bookAuthor: "à¤²à¥‡à¤–à¤•",
          yourRating: "à¤†à¤ªà¤•à¥€ à¤°à¥‡à¤Ÿà¤¿à¤‚à¤—",
          beforeReading: "à¤ªà¤¢à¤¼à¤¨à¥‡ à¤¸à¥‡ à¤ªà¤¹à¤²à¥‡",
          whileReading: "à¤ªà¤¢à¤¼à¤¤à¥‡ à¤¸à¤®à¤¯",
          afterReading: "à¤ªà¤¢à¤¼à¤¨à¥‡ à¤•à¥‡ à¤¬à¤¾à¤¦",
          addNote: "à¤¨à¥‹à¤Ÿ à¤œà¥‹à¤¡à¤¼à¥‡à¤‚",
          pageNumber: "à¤ªà¥ƒà¤·à¥à¤  à¤¸à¤‚à¤–à¥à¤¯à¤¾",
          pageOptional:
            "à¤†à¤ª à¤•à¤¿à¤¸ à¤ªà¥ƒà¤·à¥à¤  à¤ªà¤° à¤¹à¥ˆà¤‚? (à¤¯à¤¦à¤¿ à¤†à¤ª à¤ªà¥ƒà¤·à¥à¤ à¥‹à¤‚ à¤•à¥‹ à¤Ÿà¥à¤°à¥ˆà¤• à¤¨à¤¹à¥€à¤‚ à¤•à¤°à¤¨à¤¾ à¤šà¤¾à¤¹à¤¤à¥‡ à¤¹à¥ˆà¤‚ à¤¤à¥‹ à¤–à¤¾à¤²à¥€ à¤›à¥‹à¤¡à¤¼ à¤¦à¥‡à¤‚)",
          addNotePrompt: "à¤à¤• à¤‰à¤¦à¥à¤§à¤°à¤£, à¤…à¤‚à¤¶ à¤¯à¤¾ à¤…à¤ªà¤¨à¥‡ à¤µà¤¿à¤šà¤¾à¤° à¤œà¥‹à¤¡à¤¼à¥‡à¤‚:",
          page: "à¤ªà¥ƒà¤·à¥à¤ ",
          completeJourney: "à¤ªà¥‚à¤°à¥à¤£ à¤ªà¤ à¤¨ à¤¯à¤¾à¤¤à¥à¤°à¤¾",
          beforeReadingPrompt:
            "à¤ªà¤¢à¤¼à¤¨à¥‡ à¤¸à¥‡ à¤ªà¤¹à¤²à¥‡ à¤†à¤ªà¤•à¥‡ à¤µà¤¿à¤šà¤¾à¤°?\n(à¤¯à¤¹ à¤ªà¥à¤¸à¥à¤¤à¤• à¤†à¤ªà¤•à¥‹ à¤•à¥à¤¯à¥‹à¤‚ à¤†à¤•à¤°à¥à¤·à¤¿à¤¤ à¤•à¤°à¤¤à¥€ à¤¹à¥ˆ? à¤•à¥‹à¤ˆ à¤…à¤ªà¥‡à¤•à¥à¤·à¤¾à¤à¤?)",
          afterReadingPrompt:
            "à¤ªà¤¢à¤¼à¤¨à¥‡ à¤•à¥‡ à¤¬à¤¾à¤¦ à¤†à¤ªà¤•à¥‡ à¤µà¤¿à¤šà¤¾à¤°:\n(à¤…à¤¬ à¤†à¤ª à¤•à¥ˆà¤¸à¤¾ à¤®à¤¹à¤¸à¥‚à¤¸ à¤•à¤°à¤¤à¥‡ à¤¹à¥ˆà¤‚? à¤•à¥à¤¯à¤¾ à¤†à¤ªà¤•à¤¾ à¤¦à¥ƒà¤·à¥à¤Ÿà¤¿à¤•à¥‹à¤£ à¤¬à¤¦à¤²à¤¾?)",
          beforeReadingHint:
            "à¤¯à¤¹ à¤ªà¥à¤¸à¥à¤¤à¤• à¤†à¤ªà¤•à¥‹ à¤•à¥à¤¯à¥‹à¤‚ à¤†à¤•à¤°à¥à¤·à¤¿à¤¤ à¤•à¤°à¤¤à¥€ à¤¹à¥ˆ? à¤•à¥‹à¤ˆ à¤…à¤ªà¥‡à¤•à¥à¤·à¤¾à¤à¤?",
          whileReadingHint:
            "à¤ªà¤¢à¤¼à¤¤à¥‡ à¤¸à¤®à¤¯ à¤‰à¤¦à¥à¤§à¤°à¤£, à¤…à¤‚à¤¶ à¤¯à¤¾ à¤µà¤¿à¤šà¤¾à¤° à¤œà¥‹à¤¡à¤¼à¥‡à¤‚à¥¤ à¤ªà¥ƒà¤·à¥à¤  à¤¸à¤‚à¤–à¥à¤¯à¤¾ à¤¶à¤¾à¤®à¤¿à¤² à¤•à¤°à¥‡à¤‚!",
          afterReadingHint:
            "à¤…à¤¬ à¤†à¤ª à¤•à¥ˆà¤¸à¤¾ à¤®à¤¹à¤¸à¥‚à¤¸ à¤•à¤°à¤¤à¥‡ à¤¹à¥ˆà¤‚? à¤•à¥à¤¯à¤¾ à¤†à¤ªà¤•à¤¾ à¤¦à¥ƒà¤·à¥à¤Ÿà¤¿à¤•à¥‹à¤£ à¤¬à¤¦à¤²à¤¾?",
          typeHere: "à¤¯à¤¹à¤¾à¤ à¤Ÿà¤¾à¤‡à¤ª à¤•à¤°à¥‡à¤‚...",
          cancel: "à¤°à¤¦à¥à¤¦ à¤•à¤°à¥‡à¤‚",
          save: "à¤¸à¤¹à¥‡à¤œà¥‡à¤‚",
          entry: "à¤ªà¥à¤°à¤µà¤¿à¤·à¥à¤Ÿà¤¿",
          myBooks: "à¤®à¥‡à¤°à¥€ à¤ªà¥à¤¸à¥à¤¤à¤•à¥‡à¤‚",
          by: "à¤¦à¥à¤µà¤¾à¤°à¤¾",
          reading: "à¤ªà¤¢à¤¼ à¤°à¤¹à¥‡ à¤¹à¥ˆà¤‚",
          finished: "à¤¸à¤®à¤¾à¤ªà¥à¤¤",
          started: "à¤¶à¥à¤°à¥‚ à¤•à¤¿à¤¯à¤¾",
          // Tags section
          allTags: "à¤¸à¤­à¥€ à¤Ÿà¥ˆà¤—",
          times: "à¤¬à¤¾à¤°",
          rename: "à¤¨à¤¾à¤® à¤¬à¤¦à¤²à¥‡à¤‚",
          renameTag: "à¤Ÿà¥ˆà¤— à¤•à¤¾ à¤¨à¤¾à¤® à¤¬à¤¦à¤²à¥‡à¤‚",
          deleteTag: "à¤Ÿà¥ˆà¤— à¤¹à¤Ÿà¤¾à¤à¤‚",
          sortBy: "à¤‡à¤¸à¤•à¥‡ à¤…à¤¨à¥à¤¸à¤¾à¤° à¤•à¥à¤°à¤®à¤¬à¤¦à¥à¤§ à¤•à¤°à¥‡à¤‚:",
          sortByName: "à¤¨à¤¾à¤®",
          sortByUsage: "à¤‰à¤ªà¤¯à¥‹à¤—",
          frequency: "à¤†à¤µà¥ƒà¤¤à¥à¤¤à¤¿",
        },
        fr: {
          appTitle: "Journal SÃ©curisÃ© Cloud",
          localTitle: "Journal Local SÃ©curisÃ©",
          cloudModeLabel: "MODE CLOUD",
          localModeLabel: "MODE LOCAL",
          newEntry: "Nouvelle EntrÃ©e",
          viewEntries: "Voir les EntrÃ©es",
          whatOnMind: "Ã€ quoi pensez-vous?",
          addImages: "Ajouter des Images",
          addCaption: "Ajouter une lÃ©gende (optionnel)...",
          saveEntry: "Enregistrer l'EntrÃ©e",
          changePasscode: "Changer le Code",
          journalHistory: "Historique du Journal",
          searchPlaceholder: "ğŸ” Rechercher des entrÃ©es...",
          found: "TrouvÃ©",
          of: "sur",
          entries: "entrÃ©es",
          noEntries:
            'Aucune entrÃ©e trouvÃ©e. Allez Ã  "Nouvelle EntrÃ©e" pour commencer!',
          copy: "Copier",
          images: "Images",
          edit: "Modifier",
          export: "Exporter",
          delete: "Supprimer",
          privacy: "ConfidentialitÃ©",
          switchAccount: "Changer de Compte",
          switchMode: "Changer de Mode",
          signIn: "Se Connecter",
          signUp: "S'inscrire",
          useLocalMode: "Utiliser le Mode Local",
          entryLanguage: "Langue de l'EntrÃ©e",
          collapse: "RÃ©duire",
          clickToExpand: "Cliquer pour agrandir",
          clickToView: "Cliquer pour voir",
          imageRemoved: "Image supprimÃ©e",
          entrySaved: "EntrÃ©e enregistrÃ©e!",
          entryDeleted: "EntrÃ©e supprimÃ©e",
          privacyOn: "Mode confidentialitÃ© ACTIVÃ‰",
          privacyOff: "Mode confidentialitÃ© DÃ‰SACTIVÃ‰",
          books: "Livres",
          manageTags: "Ã‰tiquettes",
          exportAll: "Exporter",
          languageChanged: "Langue changÃ©e",
          language: "Langue",
          more: "Plus",
          online: "En ligne",
          offline: "Hors ligne",
          allLanguages: "Toutes les langues",
          signOutSwitchMode: "DÃ©connexion / Changer de Mode",
          // Books section
          addNewBook: "Ajouter un Nouveau Livre",
          noBooksYet:
            'Pas encore de livres. Cliquez sur "Ajouter un Nouveau Livre" pour commencer votre parcours de lecture!',
          bookTitle: "Titre du Livre",
          bookAuthor: "Auteur",
          yourRating: "Votre Note",
          beforeReading: "Avant la Lecture",
          whileReading: "Pendant la Lecture",
          afterReading: "AprÃ¨s la Lecture",
          addNote: "Ajouter une Note",
          pageNumber: "NumÃ©ro de Page",
          pageOptional:
            "Ã€ quelle page Ãªtes-vous? (Laissez vide si vous ne voulez pas suivre les pages)",
          addNotePrompt: "Ajoutez une citation, un passage ou vos pensÃ©es:",
          page: "Page",
          completeJourney: "Parcours de Lecture Complet",
          beforeReadingPrompt:
            "Vos pensÃ©es AVANT la lecture?\n(Qu'est-ce qui vous attire vers ce livre? Des attentes?)",
          afterReadingPrompt:
            "Vos pensÃ©es APRÃˆS la lecture:\n(Comment vous sentez-vous maintenant? Votre perspective a-t-elle changÃ©?)",
          beforeReadingHint:
            "Qu'est-ce qui vous attire vers ce livre? Des attentes?",
          whileReadingHint:
            "Ajoutez des citations, passages ou pensÃ©es pendant la lecture. Incluez les numÃ©ros de page!",
          afterReadingHint:
            "Comment vous sentez-vous maintenant? Votre perspective a-t-elle changÃ©?",
          typeHere: "Tapez ici...",
          cancel: "Annuler",
          save: "Enregistrer",
          entry: "entrÃ©e",
          myBooks: "Mes Livres",
          by: "par",
          reading: "En Lecture",
          finished: "TerminÃ©",
          started: "CommencÃ©",
          // Tags section
          allTags: "Toutes les Ã‰tiquettes",
          times: "fois",
          rename: "Renommer",
          renameTag: "Renommer l'Ã‰tiquette",
          deleteTag: "Supprimer l'Ã‰tiquette",
          sortBy: "Trier par:",
          sortByName: "Nom",
          sortByUsage: "Utilisation",
          frequency: "FrÃ©quence",
        },
      };

      // ğŸ†• PHASE 3: Recovery Phrase Word List (BIP39 simplified - 256 words)
      const RECOVERY_WORDS = [
        "abandon",
        "ability",
        "able",
        "about",
        "above",
        "absent",
        "absorb",
        "abstract",
        "absurd",
        "abuse",
        "access",
        "accident",
        "account",
        "accuse",
        "achieve",
        "acid",
        "acoustic",
        "acquire",
        "across",
        "act",
        "action",
        "actor",
        "actress",
        "actual",
        "adapt",
        "add",
        "addict",
        "address",
        "adjust",
        "admit",
        "adult",
        "advance",
        "advice",
        "aerobic",
        "afford",
        "afraid",
        "again",
        "age",
        "agent",
        "agree",
        "ahead",
        "aim",
        "air",
        "airport",
        "aisle",
        "alarm",
        "album",
        "alcohol",
        "alert",
        "alien",
        "all",
        "alley",
        "allow",
        "almost",
        "alone",
        "alpha",
        "already",
        "also",
        "alter",
        "always",
        "amateur",
        "amazing",
        "among",
        "amount",
        "amused",
        "analyst",
        "anchor",
        "ancient",
        "anger",
        "angle",
        "angry",
        "animal",
        "ankle",
        "announce",
        "annual",
        "another",
        "answer",
        "antenna",
        "antique",
        "anxiety",
        "any",
        "apart",
        "apology",
        "appear",
        "apple",
        "approve",
        "april",
        "arch",
        "arctic",
        "area",
        "arena",
        "argue",
        "arm",
        "armed",
        "armor",
        "army",
        "around",
        "arrange",
        "arrest",
        "arrive",
        "arrow",
        "art",
        "artefact",
        "artist",
        "artwork",
        "ask",
        "aspect",
        "assault",
        "asset",
        "assist",
        "assume",
        "asthma",
        "athlete",
        "atom",
        "attack",
        "attend",
        "attitude",
        "attract",
        "auction",
        "audit",
        "august",
        "aunt",
        "author",
        "auto",
        "autumn",
        "average",
        "avocado",
        "avoid",
        "awake",
        "aware",
        "away",
        "awesome",
        "awful",
        "awkward",
        "axis",
        "baby",
        "bachelor",
        "bacon",
        "badge",
        "bag",
        "balance",
        "balcony",
        "ball",
        "bamboo",
        "banana",
        "banner",
        "bar",
        "barely",
        "bargain",
        "barrel",
        "base",
        "basic",
        "basket",
        "battle",
        "beach",
        "bean",
        "beauty",
        "because",
        "become",
        "beef",
        "before",
        "begin",
        "behave",
        "behind",
        "believe",
        "below",
        "belt",
        "bench",
        "benefit",
        "best",
        "betray",
        "better",
        "between",
        "beyond",
        "bicycle",
        "bid",
        "bike",
        "bind",
        "biology",
        "bird",
        "birth",
        "bitter",
        "black",
        "blade",
        "blame",
        "blanket",
        "blast",
        "bleak",
        "bless",
        "blind",
        "blood",
        "blossom",
        "blouse",
        "blue",
        "blur",
        "blush",
        "board",
        "boat",
        "body",
        "boil",
        "bomb",
        "bone",
        "bonus",
        "book",
        "boost",
        "border",
        "boring",
        "borrow",
        "boss",
        "bottom",
        "bounce",
        "box",
        "boy",
        "bracket",
        "brain",
        "brand",
        "brass",
        "brave",
        "bread",
        "breeze",
        "brick",
        "bridge",
        "brief",
        "bright",
        "bring",
        "brisk",
        "broccoli",
        "broken",
        "bronze",
        "broom",
        "brother",
        "brown",
        "brush",
        "bubble",
        "buddy",
        "budget",
        "buffalo",
        "build",
        "bulb",
        "bulk",
        "bullet",
        "bundle",
        "bunker",
        "burden",
        "burger",
        "burst",
        "bus",
        "business",
        "busy",
        "butter",
        "buyer",
        "buzz",
        "cabbage",
        "cabin",
        "cable",
        "cactus",
      ];

      // ========== UTILITY FUNCTIONS ==========
      function showMessage(text, type = "success") {
        MESSAGE_BOX.textContent = text;
        MESSAGE_BOX.classList.remove(
          "hidden",
          "bg-red-100",
          "text-red-800",
          "border-red-500",
          "bg-green-100",
          "text-green-800",
          "border-green-500",
          "bg-yellow-100",
          "text-yellow-800",
          "border-yellow-500"
        );

        if (type === "error") {
          MESSAGE_BOX.classList.add(
            "bg-red-100",
            "text-red-800",
            "border-red-500"
          );
        } else if (type === "success") {
          MESSAGE_BOX.classList.add(
            "bg-green-100",
            "text-green-800",
            "border-green-500"
          );
        } else {
          MESSAGE_BOX.classList.add(
            "bg-yellow-100",
            "text-yellow-800",
            "border-yellow-500"
          );
        }

        setTimeout(() => MESSAGE_BOX.classList.add("hidden"), 5000);
      }

      // ========== PHASE 4: IMAGE HANDLING FUNCTIONS ==========

      /**
       * Handles image file selection
       */
      async function handleImageSelect(event) {
        const files = Array.from(event.target.files);

        if (files.length === 0) return;

        showMessage("Compressing images...", "info");

        // Process each file with compression
        let successCount = 0;
        for (const file of files) {
          // Validate file type
          if (!file.type.startsWith("image/")) {
            showMessage(`Skipped ${file.name} - not an image`, "error");
            continue;
          }

          try {
            const originalSize = (file.size / 1024).toFixed(0);

            // ğŸ†• Compress the image
            const compressedBase64 = await compressImage(file, 1920, 0.85);

            // Calculate compressed size
            const compressedSize = (
              (compressedBase64.length * 0.75) /
              1024
            ).toFixed(0); // Rough estimate

            // Add to current images array
            CURRENT_IMAGES.push({
              name: file.name,
              data: compressedBase64,
              type: "image/jpeg", // Always JPEG after compression
              caption: "", // ğŸ“ Caption support
            });

            successCount++;
          } catch (error) {
            console.error(`Failed to compress ${file.name}:`, error);
            showMessage(`Failed to process ${file.name}`, "error");
          }
        }

        // Update preview
        updateImagePreview();

        if (successCount > 0) {
          showMessage(
            `Added ${successCount} compressed image(s) ğŸ“¸`,
            "success"
          );
        }

        // Clear input for next selection
        event.target.value = "";
      }

      /**
       * Converts file to base64 string
       */
      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      /**
       * Compresses an image to reduce file size
       * @param {File} file - The image file to compress
       * @param {number} maxWidth - Maximum width (default 1920px)
       * @param {number} quality - JPEG quality 0-1 (default 0.85)
       * @returns {Promise<string>} - Compressed image as base64
       */
      function compressImage(file, maxWidth = 1920, quality = 0.85) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              // Calculate new dimensions
              let width = img.width;
              let height = img.height;

              if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
              }

              // Create canvas and draw resized image
              const canvas = document.createElement("canvas");
              canvas.width = width;
              canvas.height = height;
              const ctx = canvas.getContext("2d");
              ctx.drawImage(img, 0, 0, width, height);

              // Convert to base64 with compression
              const compressedBase64 = canvas.toDataURL("image/jpeg", quality);
              resolve(compressedBase64);
            };
            img.onerror = reject;
            img.src = e.target.result;
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      function animateSaveStatus(state) {
        const el = document.getElementById("saveStatus");

        if (!el) return;

        el.className = "mt-2 text-sm transition-all duration-500";

        if (state === "saving") {
          el.textContent = "ğŸ’¾ Saving...";
          el.classList.add("save-working");
        }

        if (state === "saved") {
          el.textContent = "âœ… Saved!";
          el.classList.add("save-success");

          setTimeout(() => {
            el.classList.add("save-hidden");
          }, 2000);
        }

        if (state === "error") {
          el.textContent = "âŒ Save failed";
          el.style.opacity = "1";
          el.style.color = "#ef4444";
        }
      }

      function updateSaveStatus() {
        const statusEl = document.getElementById("save-status");
        const now = new Date();

        const timeString = now.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });

        statusEl.textContent = `âœ… Last saved at ${timeString}`;
      }

      function renderTagButtons(tags) {
        const bar = document.getElementById("tagButtonBar");
        if (!bar) return;

        bar.innerHTML = "";

        tags.forEach((tag) => {
          const btn = document.createElement("button");
          btn.className = "tag-btn glow-btn";
          btn.textContent = tag;
          btn.dataset.tag = tag;

          btn.onclick = () => {
            filterByTag(tag);
            setActiveTagButton(tag);
          };

          bar.appendChild(btn);
        });
      }

      function setActiveTagButton(tag) {
        const buttons = document.querySelectorAll("#tagButtonBar button");

        buttons.forEach((btn) => {
          if (btn.dataset.tag === tag) {
            btn.classList.add("ring-2", "ring-indigo-400");
          } else {
            btn.classList.remove("ring-2", "ring-indigo-400");
          }
        });
      }

      function updateTagButtonVisibility() {
        const wrapper = document.getElementById("tagButtonWrapper");
        if (!wrapper) return;

        // Tags are only visible if:
        // - Privacy mode is OFF
        // - Manual toggle is ON
        const shouldShow = !PRIVACY_MODE && SHOW_TAG_BUTTONS;

        if (shouldShow) {
          wrapper.classList.remove("hidden");
          wrapper.classList.add("tag-fade-in");
        } else {
          wrapper.classList.add("hidden");
          wrapper.classList.remove("tag-fade-in");
        }
      }

      function toggleTagButtons() {
        SHOW_TAG_BUTTONS = !SHOW_TAG_BUTTONS;
        updateTagButtonVisibility();
      }

      /**
       * Updates the image preview display
       */
      function updateImagePreview() {
        const container = document.getElementById("imagePreviewContainer");

        if (CURRENT_IMAGES.length === 0) {
          container.classList.add("hidden");
          container.innerHTML = "";
          return;
        }

        container.classList.remove("hidden");
        container.innerHTML = "";

        CURRENT_IMAGES.forEach((img, index) => {
          const previewDiv = document.createElement("div");
          previewDiv.className = "relative group";
          previewDiv.innerHTML = `
                      <img src="${img.data}" alt="${
            img.name
          }" class="w-full h-32 object-cover rounded-lg border-2 border-gray-300 dark:border-gray-600" />
                      <button onclick="removeImage(${index})" class="glow-btn absolute top-1 right-1 bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-700 opacity-0 group-hover:opacity-100 transition">
                          Ã—
                      </button>
                      <input
                          type="text"
                          placeholder="Add caption (optional)..."
                          value="${img.caption || ""}"
                          onchange="updateImageCaption(${index}, this.value)"
                          class="w-full mt-1 px-2 py-1 text-xs border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100"
                      />
                  `;
          container.appendChild(previewDiv);
        });
      }

      /**
       * Removes an image from the current images array
       */
      function removeImage(index) {
        CURRENT_IMAGES.splice(index, 1);
        updateImagePreview();
        showMessage("Image removed", "info");
      }

      /**
       * Updates the caption for an image
       */
      function updateImageCaption(index, caption) {
        if (CURRENT_IMAGES[index]) {
          CURRENT_IMAGES[index].caption = caption;
        }
      }

      /**
       * Clears all current images
       */
      function clearCurrentImages() {
        CURRENT_IMAGES = [];
        updateImagePreview();
      }

      /**
       * Views an image in fullscreen
       */
      function viewImageFullscreen(imageSrc) {
        // Create fullscreen overlay
        const overlay = document.createElement("div");
        overlay.className =
          "fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4";
        overlay.onclick = () => overlay.remove();

        overlay.innerHTML = `
                  <div class="relative max-w-4xl max-h-full">
                      <img src="${imageSrc}" class="max-w-full max-h-screen object-contain rounded-lg" />
                      <button onclick="this.parentElement.parentElement.remove()" class="glow-btn absolute top-2 right-2 bg-red-600 text-white rounded-full w-10 h-10 flex items-center justify-center hover:bg-red-700 text-2xl">
                          Ã—
                      </button>
                  </div>
              `;

        document.body.appendChild(overlay);
      }

      // ========== PHASE 5: TAG FUNCTIONS ==========

      /**
       * Extracts tags from the tag input field and entry text
       * @returns {Array} Array of unique tag strings
       */
      function extractTags() {
        const tagInput = document.getElementById("tagInput");
        const journalText = JOURNAL_INPUT.value;
        const tags = new Set();

        // Extract from tag input field
        if (tagInput && tagInput.value.trim()) {
          const inputTags = tagInput.value
            .split(/[,\s]+/) // Split by comma or space
            .map((tag) => tag.trim())
            .filter((tag) => tag.length > 0)
            .map((tag) => (tag.startsWith("#") ? tag : "#" + tag)); // Ensure tags start with #

          inputTags.forEach((tag) => tags.add(tag.toLowerCase()));
        }

        // Extract hashtags from entry text
        const hashtagRegex = /#[\w-]+/g;
        const textTags = journalText.match(hashtagRegex) || [];
        textTags.forEach((tag) => tags.add(tag.toLowerCase()));

        return Array.from(tags);
      }

      /**
       * Clears current tags and resets the tag input
       */
      function clearCurrentTags() {
        CURRENT_TAGS = [];
        const tagInput = document.getElementById("tagInput");
        if (tagInput) {
          tagInput.value = "";
        }
        const preview = document.getElementById("tagPreviewContainer");
        if (preview) {
          preview.innerHTML = "";
          preview.classList.add("hidden");
        }
      }

      /**
       * Generates a consistent color for a tag based on its name
       * @param {string} tagName - The tag name
       * @returns {object} Object with background and text colors
       */
      function getTagColor(tagName) {
        // Hash the tag name to get a consistent number
        let hash = 0;
        for (let i = 0; i < tagName.length; i++) {
          hash = tagName.charCodeAt(i) + ((hash << 5) - hash);
        }

        // Use the hash to select from predefined color schemes
        const colors = [
          { bg: "#EF4444", text: "#FFFFFF" }, // red
          { bg: "#F59E0B", text: "#FFFFFF" }, // amber
          { bg: "#10B981", text: "#FFFFFF" }, // green
          { bg: "#3B82F6", text: "#FFFFFF" }, // blue
          { bg: "#8B5CF6", text: "#FFFFFF" }, // purple
          { bg: "#EC4899", text: "#FFFFFF" }, // pink
          { bg: "#14B8A6", text: "#FFFFFF" }, // teal
          { bg: "#F97316", text: "#FFFFFF" }, // orange
          { bg: "#06B6D4", text: "#FFFFFF" }, // cyan
          { bg: "#84CC16", text: "#FFFFFF" }, // lime
        ];

        const index = Math.abs(hash) % colors.length;
        return colors[index];
      }

      /**
       * Creates HTML for tag badges
       * @param {Array} tags - Array of tag strings
       * @param {boolean} clickable - Whether tags should be clickable for filtering
       * @returns {string} HTML string for tag badges
       */
      function renderTagBadges(tags, clickable = false) {
        if (!tags || tags.length === 0) return "";

        const isDarkMode = document.documentElement.classList.contains("dark");

        return tags
          .map((tag) => {
            const colors = getTagColor(tag);
            const darkClass = isDarkMode ? "dark-theme" : "";
            const clickHandler = clickable
              ? `onclick="filterByTag('${tag}')"`
              : "";

            // ğŸ·ï¸ Phase 5.3: Check if this tag is actively filtering
            const isActive = ACTIVE_TAG_FILTERS.has(tag.toLowerCase());
            const activeStyle = isActive
              ? "ring-4 ring-white dark:ring-gray-900 opacity-100 font-bold transform scale-110"
              : "";
            const cursorStyle = clickable ? "cursor-pointer" : "";

            return `<span
                      class="tag-badge ${darkClass} ${activeStyle} ${cursorStyle}"
                      style="background-color: ${colors.bg}; color: ${
              colors.text
            };"
                      ${clickHandler}
                      title="${
                        clickable
                          ? isActive
                            ? "Click to remove filter"
                            : "Click to filter by this tag"
                          : tag
                      }"
                  >${tag}</span>`;
          })
          .join(" ");
      }

      /**
       * Updates the tag preview area as user types (Phase 5.2)
       */
      function updateTagPreview() {
        const tagInput = document.getElementById("tagInput");
        const preview = document.getElementById("tagPreviewContainer");
        const suggestionsDropdown = document.getElementById(
          "tagSuggestionsDropdown"
        );

        if (!tagInput || !preview) return;

        const inputValue = tagInput.value.trim();

        // Extract tags from current input
        const currentTags = inputValue
          .split(/[,\s]+/)
          .map((tag) => tag.trim())
          .filter((tag) => tag.length > 0)
          .map((tag) => (tag.startsWith("#") ? tag : "#" + tag));

        // Show/hide preview based on whether there are tags
        if (currentTags.length > 0) {
          preview.innerHTML = renderTagBadges(currentTags, false);
          preview.classList.remove("hidden");
        } else {
          preview.classList.add("hidden");
        }

        // Handle tag suggestions
        const cursorPos = tagInput.selectionStart;
        const textBeforeCursor = inputValue.substring(0, cursorPos);
        const words = textBeforeCursor.split(/[,\s]+/);
        const currentWord = words[words.length - 1];

        console.log("Current word being typed:", currentWord);

        // Show suggestions if typing a tag (starts with #)
        if (currentWord.startsWith("#")) {
          showTagSuggestions(currentWord.toLowerCase());
        } else {
          suggestionsDropdown.classList.add("hidden");
        }
      }

      /**
       * Shows tag suggestions based on what user is typing (Phase 5.2)
       * @param {string} partial - The partial tag being typed
       */
      function showTagSuggestions(partial) {
        const dropdown = document.getElementById("tagSuggestionsDropdown");
        if (!dropdown) return;

        console.log("showTagSuggestions called with:", partial);
        console.log("ALL_TAGS contains:", Array.from(ALL_TAGS));

        // Filter existing tags that match the partial input
        let matches;
        if (partial === "#") {
          // Just typed #, show all tags
          matches = Array.from(ALL_TAGS).sort().slice(0, 5);
        } else {
          // Filter tags that start with the partial input
          matches = Array.from(ALL_TAGS)
            .filter((tag) =>
              tag.toLowerCase().startsWith(partial.toLowerCase())
            )
            .sort()
            .slice(0, 5); // Show max 5 suggestions
        }

        console.log("Matches found:", matches);

        if (matches.length === 0) {
          // Show a helpful message if no tags exist yet
          if (ALL_TAGS.size === 0) {
            dropdown.innerHTML = `<div class="suggestion-item text-gray-500 dark:text-gray-400 text-sm">
                          No saved tags yet. Create some tags to see suggestions!
                      </div>`;
            dropdown.classList.remove("hidden");
          } else {
            dropdown.classList.add("hidden");
          }
          return;
        }

        // Build dropdown HTML
        dropdown.innerHTML = matches
          .map((tag, index) => {
            const colors = getTagColor(tag);
            return `<div
                      class="suggestion-item flex items-center gap-2"
                      onclick="selectTagSuggestion('${tag}')"
                      data-index="${index}"
                  >
                      <span class="tag-badge" style="background-color: ${colors.bg}; color: ${colors.text};">${tag}</span>
                  </div>`;
          })
          .join("");

        dropdown.classList.remove("hidden");
        console.log("Dropdown should now be visible");
      }

      /**
       * Selects a tag from the suggestions dropdown (Phase 5.2)
       * @param {string} tag - The tag to insert
       */
      function selectTagSuggestion(tag) {
        const tagInput = document.getElementById("tagInput");
        const dropdown = document.getElementById("tagSuggestionsDropdown");

        if (!tagInput) return;

        const cursorPos = tagInput.selectionStart;
        const value = tagInput.value;
        const textBeforeCursor = value.substring(0, cursorPos);
        const textAfterCursor = value.substring(cursorPos);

        // Find the start of the current word
        const words = textBeforeCursor.split(/[,\s]+/);
        const currentWord = words[words.length - 1];
        const wordStart = textBeforeCursor.lastIndexOf(currentWord);

        // Replace current word with selected tag
        const newValue =
          value.substring(0, wordStart) + tag + ", " + textAfterCursor;
        tagInput.value = newValue;

        // Move cursor after the inserted tag
        const newCursorPos = wordStart + tag.length + 2;
        tagInput.setSelectionRange(newCursorPos, newCursorPos);

        // Hide dropdown and update preview
        dropdown.classList.add("hidden");
        updateTagPreview();
        tagInput.focus();
      }

      /**
       * Handles keyboard navigation in tag input (Phase 5.2)
       * @param {Event} event - The keyboard event
       */
      function handleTagInputKeydown(event) {
        const dropdown = document.getElementById("tagSuggestionsDropdown");

        if (!dropdown || dropdown.classList.contains("hidden")) return;

        const items = dropdown.querySelectorAll(".suggestion-item");
        if (items.length === 0) return;

        let selectedIndex = -1;
        items.forEach((item, index) => {
          if (item.classList.contains("selected")) {
            selectedIndex = index;
          }
        });

        // Handle arrow keys
        if (event.key === "ArrowDown") {
          event.preventDefault();
          selectedIndex = (selectedIndex + 1) % items.length;
        } else if (event.key === "ArrowUp") {
          event.preventDefault();
          selectedIndex =
            selectedIndex <= 0 ? items.length - 1 : selectedIndex - 1;
        } else if (event.key === "Enter" && selectedIndex >= 0) {
          event.preventDefault();
          items[selectedIndex].click();
          return;
        } else if (event.key === "Escape") {
          dropdown.classList.add("hidden");
          return;
        } else {
          return; // Let other keys work normally
        }

        // Update selected state
        items.forEach((item, index) => {
          if (index === selectedIndex) {
            item.classList.add("selected");
          } else {
            item.classList.remove("selected");
          }
        });
      }

      /**
       * Collects all unique tags from all entries (Phase 5.2)
       * @param {Array} entries - Array of journal entries
       */
      function collectAllTags(entries) {
        const tagSet = new Set();

        entries.forEach((entry) => {
          if (entry.tags && entry.tags.length > 0) {
            entry.tags.forEach((tag) => tagSet.add(tag));
          }
        });

        COLLECTED_TAGS = Array.from(tagSet);

        console.log("Collected tags:", COLLECTED_TAGS);
      }

      /**
       * Detects hashtags in journal text and shows them in preview (Phase 5.2)
       */
      function detectHashtagsInText() {
        const journalText = JOURNAL_INPUT.value;
        const tagInput = document.getElementById("tagInput");
        const preview = document.getElementById("tagPreviewContainer");

        if (!preview) return;

        // Extract hashtags from journal text
        const hashtagRegex = /#[\w-]+/g;
        const textTags = journalText.match(hashtagRegex) || [];

        // Get tags from tag input field
        let inputTags = [];
        if (tagInput && tagInput.value.trim()) {
          inputTags = tagInput.value
            .split(/[,\s]+/)
            .map((tag) => tag.trim())
            .filter((tag) => tag.length > 0)
            .map((tag) => (tag.startsWith("#") ? tag : "#" + tag));
        }

        // Combine and deduplicate tags
        const allTags = [
          ...new Set([
            ...textTags.map((t) => t.toLowerCase()),
            ...inputTags.map((t) => t.toLowerCase()),
          ]),
        ];

        // Show preview if there are any tags
        if (allTags.length > 0) {
          preview.innerHTML = renderTagBadges(allTags, false);
          preview.classList.remove("hidden");
        } else {
          preview.classList.add("hidden");
        }
      }

      // ========== PHASE 3: RECOVERY PHRASE FUNCTIONS ==========

      /**
       * Generates a 12-word recovery phrase
       * @returns {string[]} Array of 12 random words
       */
      function generateRecoveryPhrase() {
        const phrase = [];
        for (let i = 0; i < 12; i++) {
          const randomIndex = Math.floor(Math.random() * RECOVERY_WORDS.length);
          phrase.push(RECOVERY_WORDS[randomIndex]);
        }
        return phrase;
      }

      /**
       * Converts recovery phrase to a deterministic passcode
       * @param {string[]} words - Array of 12 words
       * @returns {Promise<string>} - Derived passcode
       */
      async function phraseToPasscode(words) {
        const phraseString = words.join(" ");
        const encoder = new TextEncoder();
        const data = encoder.encode(phraseString);

        // Use SHA-256 to create a hash of the phrase
        const hashBuffer = await crypto.subtle.digest("SHA-256", data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));

        // Convert to base64 for a readable passcode
        const hashHex = hashArray
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");

        // Take first 32 characters for the passcode
        return hashHex.substring(0, 32);
      }

      /**
       * Validates that input words are all from the word list
       * @param {string[]} words - Array of words to validate
       * @returns {boolean} - True if all words are valid
       */
      function validateRecoveryPhrase(words) {
        if (words.length !== 12) return false;
        return words.every((word) =>
          RECOVERY_WORDS.includes(word.toLowerCase())
        );
      }

      // ========== CUSTOM PASSWORD MODAL (Phase 2) ==========

      /**
       * Shows the custom password modal and returns a promise with the entered password
       * @param {string} title - Modal title
       * @param {string} message - Optional message/warning to display
       * @param {boolean} requireConfirm - Whether to show password confirmation field
       * @param {string} submitBtnText - Text for submit button
       * @param {string} inputType - Type of input: 'password' or 'text' (default: 'password')
       * @returns {Promise<string|null>} - Entered password or null if cancelled
       */
      function showPasswordModal(
        title = "ğŸ” Enter Passcode",
        message = "",
        requireConfirm = false,
        submitBtnText = "Continue",
        inputType = "password"
      ) {
        return new Promise((resolve) => {
          passwordModalResolver = resolve;
          passwordModalRequiresConfirm = requireConfirm;

          // Set modal content
          document.getElementById("passwordModalTitle").textContent = title;
          document.getElementById("passwordModalSubmitBtn").textContent =
            submitBtnText;

          // Show/hide message
          const messageEl = document.getElementById("passwordModalMessage");
          if (message) {
            messageEl.textContent = message;
            messageEl.classList.remove("hidden");
          } else {
            messageEl.classList.add("hidden");
          }

          // Show/hide confirm field
          const confirmSection = document.getElementById(
            "passwordConfirmSection"
          );
          if (requireConfirm) {
            confirmSection.classList.remove("hidden");
          } else {
            confirmSection.classList.add("hidden");
          }

          // Show/hide toggle buttons based on input type
          const toggleBtn = document.getElementById("passwordToggleBtn");
          const confirmToggleBtn = confirmSection.querySelector("button");
          if (inputType === "text") {
            toggleBtn.classList.add("hidden");
            if (confirmToggleBtn) confirmToggleBtn.classList.add("hidden");
          } else {
            toggleBtn.classList.remove("hidden");
            if (confirmToggleBtn) confirmToggleBtn.classList.remove("hidden");
          }

          // Clear inputs and set type
          const mainInput = document.getElementById("passwordModalInput");
          const confirmInput = document.getElementById("passwordModalConfirm");
          mainInput.value = "";
          confirmInput.value = "";
          mainInput.type = inputType;
          confirmInput.type = inputType;

          // Reset password visibility icons
          document.getElementById("passwordToggleIcon").textContent = "ğŸ‘ï¸";
          document.getElementById("confirmPasswordToggleIcon").textContent =
            "ğŸ‘ï¸";

          // Update placeholder based on type
          if (inputType === "text") {
            mainInput.placeholder = "Enter your email...";
            confirmInput.placeholder = "Confirm your email...";
          } else {
            mainInput.placeholder = "Enter your passcode...";
            confirmInput.placeholder = "Confirm your passcode...";
          }

          // Show modal
          const modal = document.getElementById("passwordModal");
          modal.classList.remove("hidden");
          modal.classList.add("flex");

          // Focus on input
          setTimeout(() => {
            mainInput.focus();
          }, 100);

          // Allow Enter key to submit
          const handleEnter = (e) => {
            if (e.key === "Enter") {
              submitPasswordModal();
            }
          };
          mainInput.addEventListener("keypress", handleEnter);
          confirmInput.addEventListener("keypress", handleEnter);
        });
      }

      function submitPasswordModal() {
        const password = document.getElementById("passwordModalInput").value;

        if (!password) {
          showMessage("Passcode cannot be empty", "error");
          return;
        }

        // If confirmation is required, check that passwords match
        if (passwordModalRequiresConfirm) {
          const confirm = document.getElementById("passwordModalConfirm").value;
          if (password !== confirm) {
            showMessage("Passcodes don't match!", "error");
            return;
          }
        }

        // Close modal
        closePasswordModal();

        // Resolve the promise with the password
        if (passwordModalResolver) {
          passwordModalResolver(password);
          passwordModalResolver = null;
        }
      }

      function cancelPasswordModal() {
        closePasswordModal();

        // Resolve the promise with null (cancelled)
        if (passwordModalResolver) {
          passwordModalResolver(null);
          passwordModalResolver = null;
        }
      }

      function closePasswordModal() {
        const modal = document.getElementById("passwordModal");
        modal.classList.add("hidden");
        modal.classList.remove("flex");
      }

      function togglePasswordVisibility() {
        const input = document.getElementById("passwordModalInput");
        const icon = document.getElementById("passwordToggleIcon");

        if (input.type === "password") {
          input.type = "text";
          icon.textContent = "ğŸ™ˆ"; // monkey covering eyes when password is visible
        } else {
          input.type = "password";
          icon.textContent = "ğŸ‘ï¸"; // eye when password is hidden
        }
      }

      function toggleConfirmPasswordVisibility() {
        const input = document.getElementById("passwordModalConfirm");
        const icon = document.getElementById("confirmPasswordToggleIcon");

        if (input.type === "password") {
          input.type = "text";
          icon.textContent = "ğŸ™ˆ";
        } else {
          input.type = "password";
          icon.textContent = "ğŸ‘ï¸";
        }
      }

      // ========== PHASE 3: RECOVERY PHRASE MODAL FUNCTIONS ==========

      let recoveryPhraseResolver = null;
      let currentRecoveryPhrase = null;

      /**
       * Shows recovery phrase modal with generated words
       * @returns {Promise<boolean>} - True if user confirmed, false if cancelled
       */
      function showRecoveryPhraseModal() {
        return new Promise((resolve) => {
          recoveryPhraseResolver = resolve;

          // Generate 12 random words
          currentRecoveryPhrase = generateRecoveryPhrase();

          // Display words in grid
          const wordsContainer = document.getElementById("recoveryPhraseWords");
          wordsContainer.innerHTML = "";

          currentRecoveryPhrase.forEach((word, index) => {
            const wordDiv = document.createElement("div");
            wordDiv.className =
              "bg-gray-100 dark:bg-gray-700 p-3 rounded-lg text-center";
            wordDiv.innerHTML = `
                          <span class="text-xs text-gray-500 dark:text-gray-400 block">${
                            index + 1
                          }</span>
                          <span class="text-sm font-semibold text-gray-800 dark:text-gray-200">${word}</span>
                      `;
            wordsContainer.appendChild(wordDiv);
          });

          // Reset checkbox and button
          const checkbox = document.getElementById("recoveryPhraseConfirm");
          const confirmBtn = document.getElementById(
            "confirmRecoveryPhraseBtn"
          );
          checkbox.checked = false;
          confirmBtn.disabled = true;

          // Add checkbox listener HERE (not in DOMContentLoaded)
          checkbox.onchange = () => {
            confirmBtn.disabled = !checkbox.checked;
          };

          // Show modal
          const modal = document.getElementById("recoveryPhraseModal");
          modal.classList.remove("hidden");
          modal.classList.add("flex");
        });
      }

      function confirmRecoveryPhrase() {
        const checkbox = document.getElementById("recoveryPhraseConfirm");
        if (!checkbox.checked) {
          showMessage(
            "Please confirm you've written down your recovery phrase",
            "error"
          );
          return;
        }

        closeRecoveryPhraseModal();

        if (recoveryPhraseResolver) {
          recoveryPhraseResolver(true);
          recoveryPhraseResolver = null;
        }
      }

      function cancelRecoveryPhrase() {
        closeRecoveryPhraseModal();
        currentRecoveryPhrase = null;

        if (recoveryPhraseResolver) {
          recoveryPhraseResolver(false);
          recoveryPhraseResolver = null;
        }
      }

      function closeRecoveryPhraseModal() {
        const modal = document.getElementById("recoveryPhraseModal");
        modal.classList.add("hidden");
        modal.classList.remove("flex");
      }

      // ========== THEME FUNCTIONS ==========
      function toggleTheme() {
        const html = document.documentElement;
        const isDarkMode = html.classList.toggle("dark");
        const icon = document.getElementById("themeIcon");
        icon.textContent = isDarkMode ? "ğŸŒ™" : "â˜€ï¸";
        localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      }

      function applySavedTheme() {
        const savedTheme = localStorage.getItem("theme") || "light";
        const html = document.documentElement;
        const icon = document.getElementById("themeIcon");

        if (savedTheme === "dark") {
          html.classList.add("dark");
          icon.textContent = "ğŸŒ™";
        } else {
          html.classList.remove("dark");
          icon.textContent = "â˜€ï¸";
        }
      }

      // ========== PRIVACY MODE FUNCTIONS ==========
      function togglePrivacyMode() {
        IMAGES_HIDDEN = !IMAGES_HIDDEN;
        const status = document.getElementById("privacyStatus");
        status.textContent = IMAGES_HIDDEN ? "ON" : "OFF";

        // Save preference
        localStorage.setItem("privacyMode", IMAGES_HIDDEN);

        // Reload entries to apply changes
        loadEntries();

        showMessage(
          IMAGES_HIDDEN
            ? "ğŸ”’ Privacy mode ON - Images hidden, entries collapsed"
            : "ğŸ”“ Privacy mode OFF - All visible",
          "info"
        );
      }

      function toggleEntryCollapse(entryId) {
        if (COLLAPSED_ENTRIES.has(entryId)) {
          COLLAPSED_ENTRIES.delete(entryId);
        } else {
          COLLAPSED_ENTRIES.add(entryId);
        }
        loadEntries();
      }

      function showImagesForEntry(entryId) {
        // Temporarily show images for this entry
        const container = document.getElementById(`images-${entryId}`);
        const placeholder = document.getElementById(
          `images-placeholder-${entryId}`
        );
        if (container && placeholder) {
          container.classList.remove("hidden");
          placeholder.classList.add("hidden");
        }
      }

      // ========== SEARCH FUNCTIONS ==========

      /**
       * Gets translated text for current UI language
       */
      function t(key) {
        return TRANSLATIONS[UI_LANGUAGE][key] || TRANSLATIONS["en"][key] || key;
      }

      /**
       * Changes the UI language
       */
      function changeUILanguage(langCode) {
        UI_LANGUAGE = langCode;
        localStorage.setItem("uiLanguage", langCode);

        const t = TRANSLATIONS[langCode] || TRANSLATIONS.en;

        // Apply RTL if Arabic
        const lang = AVAILABLE_LANGUAGES.find((l) => l.code === langCode);
        if (lang && lang.rtl) {
          document.documentElement.setAttribute("dir", "rtl");
        } else {
          document.documentElement.setAttribute("dir", "ltr");
        }

        // Update app title
        const appTitle = document.getElementById("appTitle");
        const appMode = document.getElementById("appMode");
        if (appTitle) {
          const titleText = IS_LOCAL_MODE ? t.localTitle : t.appTitle;
          const modeText = IS_LOCAL_MODE ? t.localModeLabel : t.cloudModeLabel;
          appTitle.innerHTML = `${titleText} <span id="appMode" class="text-xs sm:text-sm bg-green-500 text-white px-2 py-1 rounded">${modeText}</span>`;
        }

        // Update navigation buttons (check if they exist first)
        const viewEntriesBtn = document.getElementById("viewEntriesBtn");
        if (viewEntriesBtn) viewEntriesBtn.innerHTML = `ğŸ“ ${t.viewEntries}`;

        const newEntryBtn = document.getElementById("newEntryBtn");
        if (newEntryBtn) newEntryBtn.innerHTML = `âœ¨ ${t.newEntry}`;

        // Update menu items (now in More menu)
        const booksMenuBtn = document.getElementById("booksMenuBtn");
        if (booksMenuBtn)
          booksMenuBtn.innerHTML = `ğŸ“š <span>${t.books || "Books"}</span>`;

        const tagsMenuBtn = document.getElementById("tagsMenuBtn");
        if (tagsMenuBtn)
          tagsMenuBtn.innerHTML = `ğŸ·ï¸ <span>${t.manageTags || "Tags"}</span>`;

        const exportMenuBtn = document.getElementById("exportMenuBtn");
        if (exportMenuBtn)
          exportMenuBtn.innerHTML = `ğŸ“¤ <span>${
            t.exportAll || "Export"
          }</span>`;

        // Update More button
        const moreMenuBtn = document.getElementById("moreMenuBtn");
        if (moreMenuBtn) {
          moreMenuBtn.innerHTML = `<span class="hidden sm:inline">${t.more} â‹®</span><span class="sm:hidden">â˜°</span>`;
        }

        // Update "Language" label in menu
        const langLabels = document.querySelectorAll("label");
        langLabels.forEach((label) => {
          if (label.textContent.includes("ğŸŒ")) {
            label.innerHTML = `ğŸŒ ${t.language}`;
          }
        });

        // Update new entry view
        const newEntryTitle = document.querySelector("#newEntryView h2");
        if (newEntryTitle) newEntryTitle.textContent = t.newEntry;

        const journalInput = document.getElementById("journalInput");
        if (journalInput) journalInput.placeholder = t.whatOnMind;

        // Update "Add Images" button
        const addImagesBtn = document.querySelector(
          'button[onclick*="imageInput"]'
        );
        if (addImagesBtn) {
          addImagesBtn.innerHTML = `ğŸ“· ${t.addImages}`;
        }

        // Update "Securely Save Entry" button
        const saveEntryBtn = document.getElementById("saveEntryBtn");
        if (saveEntryBtn) saveEntryBtn.textContent = t.saveEntry;

        // Update "Change Passcode" button
        const changePasscodeBtn = document.getElementById("changePasscodeBtn");
        if (changePasscodeBtn) changePasscodeBtn.textContent = t.changePasscode;

        // Update entries list view
        const entriesTitle = document.querySelector("#entriesListView h2");
        if (entriesTitle) entriesTitle.textContent = t.journalHistory;

        const searchInput = document.getElementById("searchInput");
        if (searchInput)
          searchInput.placeholder =
            t.searchPlaceholder || "ğŸ” Search entries or type #tag...";

        // Update language filter "All Languages" option
        const languageFilter = document.getElementById("languageFilter");
        if (languageFilter && languageFilter.options[0]) {
          languageFilter.options[0].text = t.allLanguages;
        }

        // Update Privacy button
        const privacyToggle = document.getElementById("privacyToggle");
        if (privacyToggle) {
          const status = document.getElementById("privacyStatus").textContent;
          privacyToggle.innerHTML = `ğŸ”’ <span class="hidden sm:inline">${t.privacy}:</span> <span id="privacyStatus">${status}</span>`;
        }

        // Update Sign Out / Switch Mode button
        const signOutBtn = document.getElementById("signOutBtn");
        if (signOutBtn) {
          signOutBtn.innerHTML = `<span class="hidden sm:inline">${
            t.signOutSwitchMode.split(" / ")[0]
          } / </span>${t.signOutSwitchMode.split(" / ")[1]}`;
        }

        // Update connection status
        const connectionText = document.getElementById("connectionText");
        if (connectionText && navigator.onLine) {
          connectionText.textContent = t.online;
        } else if (connectionText) {
          connectionText.textContent = t.offline;
        }

        // Update Books section
        const addNewBookBtn = document.getElementById("addNewBookBtn");
        if (addNewBookBtn) {
          addNewBookBtn.textContent = `+ ${t.addNewBook}`;
        }

        const noBooksMessage = document.getElementById("noBooksMessage");
        if (noBooksMessage) {
          noBooksMessage.textContent = t.noBooksYet;
        }

        // Update Tags section
        const tagsTitle = document.querySelector("#manageTagsView h2");
        if (tagsTitle) {
          tagsTitle.textContent = `ğŸ·ï¸ ${t.manageTags}`;
        }

        const sortByLabel = document.querySelector("#manageTagsView label");
        if (sortByLabel) {
          sortByLabel.textContent = t.sortBy;
        }

        const sortByNameBtn = document.getElementById("sortByName");
        if (sortByNameBtn) sortByNameBtn.textContent = t.sortByName;

        const sortByUsageBtn = document.getElementById("sortByUsage");
        if (sortByUsageBtn) sortByUsageBtn.textContent = t.sortByUsage;

        const sortByCountBtn = document.getElementById("sortByCount");
        if (sortByCountBtn) sortByCountBtn.textContent = t.frequency;

        // Update My Books title
        const myBooksTitle = document.getElementById("myBooksTitle");
        if (myBooksTitle) {
          myBooksTitle.textContent = `ğŸ“š ${t.myBooks || "My Books"}`;
        }

        // Update modal elements
        const modalTextarea = document.getElementById("textInputModalTextarea");
        if (modalTextarea) {
          modalTextarea.placeholder = t.typeHere || "Type here...";
        }

        const modalCancelBtn = document.getElementById(
          "textInputModalCancelBtn"
        );
        if (modalCancelBtn) modalCancelBtn.textContent = t.cancel || "Cancel";

        const modalSaveBtn = document.getElementById("textInputModalSaveBtn");
        if (modalSaveBtn) modalSaveBtn.textContent = t.save || "Save";

        // Reload entries to update language (this will update entry buttons)
        if (CURRENT_PASSWORD) {
          loadEntries();
        }

        showMessage(
          t.languageChanged || `Language changed to ${lang.name}`,
          "success"
        );
      }

      /**
       * Filters entries based on search input
       */
      function filterEntries() {
        const searchTerm = document
          .getElementById("searchInput")
          .value.toLowerCase()
          .trim();
        const languageFilter = document.getElementById("languageFilter").value;
        const resultsCount = document.getElementById("searchResultsCount");

        // Start with all entries
        let filteredEntries = ALL_ENTRIES;

        // Apply language filter first if selected
        if (languageFilter) {
          filteredEntries = filteredEntries.filter(
            (entry) => entry.language === languageFilter
          );
        }

        // If no search term, show filtered results
        if (searchTerm === "") {
          if (languageFilter) {
            const langInfo = getLanguageInfo(languageFilter);
            resultsCount.textContent = `Showing ${filteredEntries.length} ${
              langInfo.flag
            } ${langInfo.name} ${
              filteredEntries.length === 1 ? "entry" : "entries"
            }`;
            resultsCount.classList.remove("hidden");
          } else {
            resultsCount.classList.add("hidden");
          }
          renderEntries(filteredEntries);
          return;
        }

        // ğŸ·ï¸ Phase 5.3: Check if searching for a tag (starts with #)
        if (searchTerm.startsWith("#")) {
          const searchTag = searchTerm.toLowerCase();
          filteredEntries = filteredEntries.filter((entry) => {
            if (!entry.tags || entry.tags.length === 0) return false;
            return entry.tags.some((tag) => tag.toLowerCase() === searchTag);
          });

          resultsCount.textContent = `Found ${filteredEntries.length} ${
            filteredEntries.length === 1 ? "entry" : "entries"
          } with tag ${searchTerm}`;
          resultsCount.classList.remove("hidden");
          renderEntries(filteredEntries);
          return;
        }

        // Filter entries that match search term
        filteredEntries = filteredEntries.filter((entry) => {
          // Search in text
          const textMatch = entry.text.toLowerCase().includes(searchTerm);

          // Search in timestamp
          const timestampMatch = entry.timestamp
            .toLowerCase()
            .includes(searchTerm);

          // ğŸ” Special: If searching for "image" or "images", find entries that HAVE images
          const hasImagesKeyword =
            searchTerm === "image" ||
            searchTerm === "images" ||
            searchTerm === "photo" ||
            searchTerm === "photos" ||
            searchTerm === "picture" ||
            searchTerm === "pictures";
          const hasImagesMatch =
            hasImagesKeyword && entry.images && entry.images.length > 0;

          // Search in image names (if entry has images)
          let imageNameMatch = false;
          if (entry.images && entry.images.length > 0) {
            imageNameMatch = entry.images.some((img) =>
              img.name.toLowerCase().includes(searchTerm)
            );
          }

          // ğŸ·ï¸ Phase 5.3: Search in tags (partial match)
          let tagMatch = false;
          if (entry.tags && entry.tags.length > 0) {
            tagMatch = entry.tags.some((tag) =>
              tag.toLowerCase().includes(searchTerm)
            );
          }

          return (
            textMatch ||
            timestampMatch ||
            hasImagesMatch ||
            imageNameMatch ||
            tagMatch
          );
        });

        // Show results count
        resultsCount.textContent = `Found ${filteredEntries.length} of ${ALL_ENTRIES.length} entries`;
        resultsCount.classList.remove("hidden");

        // Render filtered entries
        renderEntries(filteredEntries);
      }

      /**
       * Clears search and shows all entries
       */
      function clearSearch() {
        document.getElementById("searchInput").value = "";
        document.getElementById("languageFilter").value = ""; // Clear language filter
        document.getElementById("searchResultsCount").classList.add("hidden");
        renderEntries(ALL_ENTRIES);
      }

      /**
       * ğŸ·ï¸ Filters entries by tag (Phase 5.3)
       * @param {string} tag - The tag to filter by
       */
      function filterByTag(tag) {
        const normalizedTag = tag.toLowerCase();

        // Toggle the tag in active filters
        if (ACTIVE_TAG_FILTERS.has(normalizedTag)) {
          ACTIVE_TAG_FILTERS.delete(normalizedTag);
        } else {
          ACTIVE_TAG_FILTERS.add(normalizedTag);
        }

        // Apply the filter
        applyTagFilters();
      }

      /**
       * ğŸ·ï¸ Applies active tag filters to entries (Phase 5.3)
       */
      function applyTagFilters() {
        if (ACTIVE_TAG_FILTERS.size === 0) {
          // No filters active - show all entries
          renderEntries(ALL_ENTRIES);
          updateTagFilterDisplay();
          return;
        }

        // Filter entries that have ALL active tags
        const filteredEntries = ALL_ENTRIES.filter((entry) => {
          if (!entry.tags || entry.tags.length === 0) return false;

          const entryTags = entry.tags.map((t) => t.toLowerCase());

          // Entry must have ALL active filter tags
          for (const filterTag of ACTIVE_TAG_FILTERS) {
            if (!entryTags.includes(filterTag)) {
              return false;
            }
          }
          return true;
        });

        // Show filtered results
        renderEntries(filteredEntries);
        updateTagFilterDisplay();

        const filterCount = ACTIVE_TAG_FILTERS.size;
        const resultCount = filteredEntries.length;
        showMessage(
          `Showing ${resultCount} ${
            resultCount === 1 ? "entry" : "entries"
          } with ${filterCount} ${filterCount === 1 ? "tag" : "tags"}`,
          "info"
        );
      }

      /**
       * ğŸ·ï¸ Updates visual display of active tag filters (Phase 5.3)
       */
      function updateTagFilterDisplay() {
        const filterContainer = document.getElementById("activeTagFilters");
        const badgesContainer = document.getElementById("activeTagBadges");

        if (!filterContainer || !badgesContainer) return;

        if (ACTIVE_TAG_FILTERS.size === 0) {
          filterContainer.classList.add("hidden");
          return;
        }

        // Show the filter container and populate with active tags
        filterContainer.classList.remove("hidden");
        const activeTags = Array.from(ACTIVE_TAG_FILTERS);
        badgesContainer.innerHTML = renderTagBadges(activeTags, false);
      }

      /**
       * ğŸ·ï¸ Clears all active tag filters (Phase 5.3)
       */
      function clearTagFilters() {
        ACTIVE_TAG_FILTERS.clear();
        updateTagFilterDisplay(); // ğŸ·ï¸ Update the visual display (hide banner)
        renderEntries(ALL_ENTRIES);
        showMessage("Tag filters cleared", "success");
      }

      // ========== PHASE 5.4: TAG MANAGEMENT FUNCTIONS ==========

      /**
       * Displays the tag management view with all tags
       */
      function displayTagManagement() {
        const tagsGrid = document.getElementById("tagsGrid");
        const noTagsMessage = document.getElementById("noTagsMessage");

        if (!tagsGrid || !noTagsMessage) return;

        // Get tag statistics
        const tagStats = getTagStatistics();

        if (tagStats.length === 0) {
          tagsGrid.innerHTML = "";
          noTagsMessage.classList.remove("hidden");
          return;
        }

        noTagsMessage.classList.add("hidden");

        const t = TRANSLATIONS[UI_LANGUAGE] || TRANSLATIONS.en;

        // Sort tags based on current preference
        sortTagStats(tagStats);

        // Render tag cards
        tagsGrid.innerHTML = tagStats
          .map((stat) => {
            const colors = getTagColor(stat.tag);
            return `
                      <div class="p-4 border border-gray-200 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700">
                          <div class="flex items-center justify-between mb-2">
                              <span class="tag-badge" style="background-color: ${
                                colors.bg
                              }; color: ${colors.text};">
                                  ${stat.tag}
                              </span>
                              <span class="text-sm text-gray-500 dark:text-gray-400">${
                                stat.count
                              } ${
              stat.count === 1 ? t.entry || "entry" : t.entries || "entries"
            }</span>
                          </div>
                          <div class="flex gap-2 mt-3">
                              <button
                                  onclick="renameTag('${stat.tag}')"
                                  class="glow-btn flex-1 px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 transition"
                                  title="${t.renameTag || "Rename this tag"}"
                              >
                                  âœï¸ ${t.rename}
                              </button>
                              <button
                                  onclick="deleteTag('${stat.tag}')"
                                  class="glow-btn flex-1 px-3 py-1 bg-red-500 text-white text-sm rounded hover:bg-red-600 transition"
                                  title="${
                                    t.deleteTag ||
                                    "Delete this tag from all entries"
                                  }"
                              >
                                  ğŸ—‘ï¸ ${t.delete}
                              </button>
                          </div>
                      </div>
                  `;
          })
          .join("");
      }

      /**
       * Gets statistics for all tags (count of usage)
       * @returns {Array} Array of {tag, count} objects
       */
      function getTagStatistics() {
        const tagCounts = new Map();

        ALL_ENTRIES.forEach((entry) => {
          if (entry.tags && Array.isArray(entry.tags)) {
            entry.tags.forEach((tag) => {
              const normalizedTag = tag.toLowerCase();
              tagCounts.set(
                normalizedTag,
                (tagCounts.get(normalizedTag) || 0) + 1
              );
            });
          }
        });

        return Array.from(tagCounts.entries()).map(([tag, count]) => ({
          tag,
          count,
        }));
      }

      /**
       * Sorts tag statistics based on preference
       * @param {Array} tagStats - Array of tag statistics
       */
      function sortTagStats(tagStats) {
        if (TAG_SORT_BY === "name") {
          tagStats.sort((a, b) => a.tag.localeCompare(b.tag));
        } else {
          tagStats.sort((a, b) => b.count - a.count);
        }
      }

      /**
       * Changes the sort method for tags
       * @param {string} sortBy - 'name' or 'count'
       */
      function sortTagsBy(sortBy) {
        TAG_SORT_BY = sortBy;

        // Update button styles
        const nameBtn = document.getElementById("sortByName");
        const countBtn = document.getElementById("sortByCount");

        if (sortBy === "name") {
          nameBtn.className =
            "px-4 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition text-sm";
          countBtn.className =
            "px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-500 transition text-sm";
        } else {
          countBtn.className =
            "px-4 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition text-sm";
          nameBtn.className =
            "px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-500 transition text-sm";
        }

        // Re-display with new sort
        displayTagManagement();
      }

      /**
       * Renames a tag across all entries
       * @param {string} oldTag - The tag to rename
       */
      async function renameTag(oldTag) {
        const newTagName = prompt(`Rename "${oldTag}" to:`, oldTag);

        if (!newTagName || newTagName.trim() === "") {
          showMessage("Rename cancelled", "info");
          return;
        }

        let newTag = newTagName.trim().toLowerCase();
        if (!newTag.startsWith("#")) {
          newTag = "#" + newTag;
        }

        if (newTag === oldTag.toLowerCase()) {
          showMessage("No change needed", "info");
          return;
        }

        try {
          let entries = await getDecryptedEntries();
          let updateCount = 0;

          entries.forEach((entry) => {
            if (entry.tags && Array.isArray(entry.tags)) {
              const tagIndex = entry.tags.findIndex(
                (t) => t.toLowerCase() === oldTag.toLowerCase()
              );
              if (tagIndex !== -1) {
                entry.tags[tagIndex] = newTag;
                updateCount++;
              }
            }
          });

          if (updateCount > 0) {
            await saveEncryptedEntries(entries);
            ALL_ENTRIES = entries;
            collectAllTags(entries);
            renderTagButtons(tags);
            displayTagManagement();
            showMessage(
              `Renamed "${oldTag}" to "${newTag}" in ${updateCount} ${
                updateCount === 1 ? "entry" : "entries"
              }! ğŸ‰`,
              "success"
            );
          } else {
            showMessage("No entries found with that tag", "info");
          }
        } catch (error) {
          console.error("Error renaming tag:", error);
          showMessage("Error renaming tag", "error");
        }
      }

      /**
       * Deletes a tag from all entries
       * @param {string} tag - The tag to delete
       */
      async function deleteTag(tag) {
        if (
          !confirm(`Delete "${tag}" from all entries? This cannot be undone.`)
        ) {
          return;
        }

        try {
          let entries = await getDecryptedEntries();
          let updateCount = 0;

          entries.forEach((entry) => {
            if (entry.tags && Array.isArray(entry.tags)) {
              const initialLength = entry.tags.length;
              entry.tags = entry.tags.filter(
                (t) => t.toLowerCase() !== tag.toLowerCase()
              );
              if (entry.tags.length < initialLength) {
                updateCount++;
              }
            }
          });

          if (updateCount > 0) {
            await saveEncryptedEntries(entries);
            ALL_ENTRIES = entries;
            collectAllTags(entries);
            displayTagManagement();
            showMessage(
              `Deleted "${tag}" from ${updateCount} ${
                updateCount === 1 ? "entry" : "entries"
              }! ğŸ—‘ï¸`,
              "success"
            );
          } else {
            showMessage("No entries found with that tag", "info");
          }
        } catch (error) {
          console.error("Error deleting tag:", error);
          showMessage("Error deleting tag", "error");
        }
      }

      // ========== PHASE 6: BOOKS TRACKING FUNCTIONS ==========

      // Text Input Modal (replaces prompt() for books)
      let textInputModalResolver = null;

      function showTextInputModal(title, message, defaultValue = "") {
        return new Promise((resolve) => {
          textInputModalResolver = resolve;
          const modal = document.getElementById("textInputModal");
          const titleEl = document.getElementById("textInputModalTitle");
          const messageEl = document.getElementById("textInputModalMessage");
          const textarea = document.getElementById("textInputModalTextarea");

          titleEl.textContent = title;
          messageEl.textContent = message;
          textarea.value = defaultValue;

          modal.classList.remove("hidden");
          modal.classList.add("flex");
          textarea.focus();
        });
      }

      function submitTextInputModal() {
        const textarea = document.getElementById("textInputModalTextarea");
        const value = textarea.value;
        const modal = document.getElementById("textInputModal");

        modal.classList.add("hidden");
        modal.classList.remove("flex");

        if (textInputModalResolver) {
          textInputModalResolver(value);
          textInputModalResolver = null;
        }
      }

      function cancelTextInputModal() {
        const modal = document.getElementById("textInputModal");
        modal.classList.add("hidden");
        modal.classList.remove("flex");

        if (textInputModalResolver) {
          textInputModalResolver(null);
          textInputModalResolver = null;
        }
      }

      /**
       * Displays the books list view
       */
      function displayBooks() {
        const booksList = document.getElementById("booksList");
        const noBooksMessage = document.getElementById("noBooksMessage");

        if (!booksList || !noBooksMessage) return;

        if (ALL_BOOKS.length === 0) {
          booksList.innerHTML = "";
          noBooksMessage.classList.remove("hidden");
          return;
        }

        noBooksMessage.classList.add("hidden");

        const t = TRANSLATIONS[UI_LANGUAGE] || TRANSLATIONS.en;

        // Sort books by most recently updated
        const sortedBooks = [...ALL_BOOKS].sort(
          (a, b) => b.updatedAt - a.updatedAt
        );

        booksList.innerHTML = sortedBooks
          .map((book) => {
            const statusBadge = book.afterReading
              ? `<span class="px-2 py-1 bg-green-500 text-white text-xs rounded-full">${
                  t.finished || "Finished"
                }</span>`
              : `<span class="px-2 py-1 bg-blue-500 text-white text-xs rounded-full">${
                  t.reading || "Reading"
                }</span>`;

            return `
                      <div class="p-4 border border-gray-200 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 hover:shadow-md transition cursor-pointer" onclick="viewBook(${
                        book.id
                      })">
                          <div class="flex justify-between items-start">
                              <div class="flex-1">
                                  <h3 class="text-lg font-bold text-gray-800 dark:text-gray-200">${
                                    book.title
                                  }</h3>
                                  <p class="text-sm text-gray-600 dark:text-gray-400">${
                                    t.by || "by"
                                  } ${book.author}</p>
                                  <p class="text-xs text-gray-500 dark:text-gray-500 mt-1">${
                                    t.started || "Started"
                                  }: ${new Date(
              book.createdAt
            ).toLocaleDateString()}</p>
                              </div>
                              <div class="flex flex-col items-end gap-2">
                                  ${statusBadge}
                                  <button onclick="deleteBook(${
                                    book.id
                                  }); event.stopPropagation();" class="glow-btn text-xs text-red-500 hover:text-red-700 dark:text-red-400">
                                      ğŸ—‘ï¸ ${t.delete}
                                  </button>
                              </div>
                          </div>
                      </div>
                  `;
          })
          .join("");
      }

      /**
       * Starts tracking a new book
       */
      async function startNewBook() {
        const t = TRANSLATIONS[UI_LANGUAGE] || TRANSLATIONS.en;

        const title = await showTextInputModal(
          `ğŸ“š ${t.addNewBook}`,
          t.bookTitle + "?"
        );
        if (!title || !title.trim()) {
          showMessage("Book creation cancelled", "info");
          return;
        }

        const author = await showTextInputModal(
          `ğŸ“š ${t.addNewBook}`,
          t.bookAuthor + "?"
        );
        if (!author || !author.trim()) {
          showMessage("Book creation cancelled", "info");
          return;
        }

        const bookId = Date.now();
        const newBook = {
          id: bookId,
          title: title.trim(),
          author: author.trim(),
          beforeReading: null,
          whileReading: [], // ğŸ“ Array of notes while reading
          afterReading: null,
          rating: 0, // â­ 0-5 stars
          createdAt: bookId,
          updatedAt: bookId,
        };

        ALL_BOOKS.push(newBook);
        await saveBooks();

        // Go to the book detail view
        viewBook(bookId);
        showMessage(
          "Book added! Add your reflections whenever you're ready. ğŸ“š",
          "success"
        );
      }

      /**
       * Views a specific book's details
       * @param {number} bookId - The book ID
       */
      function viewBook(bookId) {
        const book = ALL_BOOKS.find((b) => b.id === bookId);
        if (!book) {
          showMessage("Book not found", "error");
          return;
        }

        CURRENT_BOOK_ID = bookId;
        const t = TRANSLATIONS[UI_LANGUAGE] || TRANSLATIONS.en;

        // Hide books list, show detail view
        document.getElementById("booksView").classList.add("hidden");
        const detailView = document.getElementById("bookDetailView");
        detailView.classList.remove("hidden");

        // Build rating stars
        const rating = book.rating || 0;
        const starsHTML = [1, 2, 3, 4, 5]
          .map(
            (star) =>
              `<span class="cursor-pointer text-2xl ${
                star <= rating ? "text-yellow-500" : "text-gray-300"
              }" onclick="setBookRating(${star})">â˜…</span>`
          )
          .join("");

        // Render book detail
        detailView.innerHTML = `
                  <div class="mb-6">
                      <button onclick="backToBooksList()" class="glow-btn text-indigo-600 dark:text-indigo-400 hover:underline mb-4">
                          â† ${t.books}
                      </button>
                      <div class="flex justify-between items-start">
                          <div>
                              <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-200">${
                                book.title
                              }</h2>
                              <p class="text-gray-600 dark:text-gray-400">by ${
                                book.author
                              }</p>
                          </div>
                          <div class="text-right">
                              <p class="text-xs text-gray-500 mb-1">${
                                t.yourRating
                              }:</p>
                              <div class="flex gap-1">${starsHTML}</div>
                          </div>
                      </div>
                  </div>

                  <!-- Before Reading -->
                  <div class="mb-6 border border-blue-200 dark:border-blue-800 rounded-lg p-4 bg-blue-50 dark:bg-blue-950">
                      <div class="flex justify-between items-center mb-3">
                          <h3 class="text-lg font-semibold text-blue-700 dark:text-blue-300">ğŸ“– ${
                            t.beforeReading
                          }</h3>
                          <button onclick="editBeforeReading()" class="glow-btn text-sm px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">
                              ${
                                book.beforeReading
                                  ? "âœï¸ " + t.edit
                                  : "+ " + t.addNote.split(" ")[0]
                              }
                          </button>
                      </div>
                      ${
                        book.beforeReading
                          ? `
                          <div class="text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap">${
                            book.beforeReading.thoughts
                          }</div>
                          <p class="text-xs text-gray-500 dark:text-gray-400 mt-2">Added: ${new Date(
                            book.beforeReading.date
                          ).toLocaleDateString()}</p>
                      `
                          : `
                          <p class="text-sm text-gray-600 dark:text-gray-400 italic">${t.beforeReadingHint}</p>
                      `
                      }
                  </div>

                  <!-- While Reading -->
                  <div class="mb-6 border border-purple-200 dark:border-purple-800 rounded-lg p-4 bg-purple-50 dark:bg-purple-950">
                      <div class="flex justify-between items-center mb-3">
                          <h3 class="text-lg font-semibold text-purple-700 dark:text-purple-300">ğŸ“ ${
                            t.whileReading
                          }</h3>
                          <button onclick="addWhileReadingNote()" class="glow-btn text-sm px-3 py-1 bg-purple-500 text-white rounded hover:bg-purple-600">
                              + ${t.addNote}
                          </button>
                      </div>
                      ${
                        book.whileReading && book.whileReading.length > 0
                          ? `
                          <div class="space-y-3">
                              ${book.whileReading
                                .map(
                                  (note, index) => `
                                  <div class="bg-white dark:bg-gray-800 p-3 rounded border border-purple-200 dark:border-purple-700">
                                      ${
                                        note.page
                                          ? `<p class="text-xs text-purple-600 dark:text-purple-400 font-semibold mb-1">ğŸ“„ ${t.page} ${note.page}</p>`
                                          : ""
                                      }
                                      <p class="text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap">${
                                        note.text
                                      }</p>
                                      <div class="flex justify-between items-center mt-2">
                                          <p class="text-xs text-gray-500 dark:text-gray-400">${new Date(
                                            note.date
                                          ).toLocaleDateString()}</p>
                                          <button onclick="deleteWhileReadingNote(${index})" class="glow-btn text-xs text-red-500 hover:text-red-700">ğŸ—‘ï¸ ${
                                    t.delete
                                  }</button>
                                      </div>
                                  </div>
                              `
                                )
                                .join("")}
                          </div>
                      `
                          : `
                         <p class="text-sm text-gray-600 dark:text-gray-400 italic">${t.whileReadingHint}</p>
                      `
                      }
                  </div>

                  <!-- After Reading -->
                  <div class="mb-6 border border-green-200 dark:border-green-800 rounded-lg p-4 bg-green-50 dark:bg-green-950">
                      <div class="flex justify-between items-center mb-3">
                          <h3 class="text-lg font-semibold text-green-700 dark:text-green-300">âœ¨ ${
                            t.afterReading
                          }</h3>
                          <button onclick="editAfterReading()" class="glow-btn text-sm px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600">
                              ${
                                book.afterReading
                                  ? "âœï¸ " + t.edit
                                  : "+ " + t.addNote.split(" ")[0]
                              }
                          </button>
                      </div>
                      ${
                        book.afterReading
                          ? `
                          <div class="text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap">${
                            book.afterReading.thoughts
                          }</div>
                          <p class="text-xs text-gray-500 dark:text-gray-400 mt-2">Added: ${new Date(
                            book.afterReading.date
                          ).toLocaleDateString()}</p>
                      `
                          : `
                          <p class="text-sm text-gray-600 dark:text-gray-400 italic">${t.afterReadingHint}</p>
                      `
                      }
                  </div>

                  ${
                    book.beforeReading && book.afterReading
                      ? `
                      <div class="p-4 bg-gradient-to-r from-blue-100 to-green-100 dark:from-blue-900 dark:to-green-900 border border-indigo-300 dark:border-indigo-700 rounded-lg">
                          <h3 class="text-lg font-semibold text-indigo-700 dark:text-indigo-300 mb-2">ğŸ”„ ${
                            t.completeJourney
                          }</h3>
                          <p class="text-sm text-indigo-900 dark:text-indigo-100">
                              You've documented your complete journey with this book! ${
                                book.whileReading &&
                                book.whileReading.length > 0
                                  ? `You captured ${
                                      book.whileReading.length
                                    } note${
                                      book.whileReading.length === 1 ? "" : "s"
                                    } while reading.`
                                  : ""
                              } ${
                          rating > 0
                            ? `You rated it ${rating} star${
                                rating === 1 ? "" : "s"
                              }.`
                            : ""
                        }
                          </p>
                      </div>
                  `
                      : ""
                  }
              `;
      }

      /**
       * Returns to books list from detail view
       */
      function backToBooksList() {
        document.getElementById("bookDetailView").classList.add("hidden");
        document.getElementById("booksView").classList.remove("hidden");
        CURRENT_BOOK_ID = null;
        displayBooks();
      }

      /**
       * Edits the "before reading" reflection
       */
      async function editBeforeReading() {
        const book = ALL_BOOKS.find((b) => b.id === CURRENT_BOOK_ID);
        if (!book) return;

        const t = TRANSLATIONS[UI_LANGUAGE] || TRANSLATIONS.en;

        const currentThoughts = book.beforeReading
          ? book.beforeReading.thoughts
          : "";
        const thoughts = await showTextInputModal(
          `ğŸ“– ${t.beforeReading}`,
          t.beforeReadingPrompt,
          currentThoughts
        );

        if (thoughts === null || thoughts === undefined) {
          showMessage("Edit cancelled", "info");
          return;
        }

        book.beforeReading = {
          thoughts: thoughts.trim(),
          date: Date.now(),
        };
        book.updatedAt = Date.now();

        await saveBooks();
        viewBook(CURRENT_BOOK_ID);
        showMessage("Before reading reflection saved! ğŸ“–", "success");
      }

      /**
       * Edits the "after reading" reflection
       */
      async function editAfterReading() {
        const book = ALL_BOOKS.find((b) => b.id === CURRENT_BOOK_ID);
        if (!book) return;

        const t = TRANSLATIONS[UI_LANGUAGE] || TRANSLATIONS.en;

        const currentThoughts = book.afterReading
          ? book.afterReading.thoughts
          : "";
        const thoughts = await showTextInputModal(
          `âœ¨ ${t.afterReading}`,
          t.afterReadingPrompt,
          currentThoughts
        );

        if (thoughts === null || thoughts === undefined) {
          showMessage("Edit cancelled", "info");
          return;
        }

        book.afterReading = {
          thoughts: thoughts.trim(),
          date: Date.now(),
        };
        book.updatedAt = Date.now();

        await saveBooks();
        viewBook(CURRENT_BOOK_ID);
        showMessage("After reading reflection saved! âœ¨", "success");
      }

      /**
       * Sets the rating for the current book
       * @param {number} stars - Rating from 1-5
       */
      async function setBookRating(stars) {
        const book = ALL_BOOKS.find((b) => b.id === CURRENT_BOOK_ID);
        if (!book) return;

        book.rating = stars;
        book.updatedAt = Date.now();

        await saveBooks();
        viewBook(CURRENT_BOOK_ID);
        showMessage(
          `Rated ${stars} star${stars === 1 ? "" : "s"}! â­`,
          "success"
        );
      }

      /**
       * Adds a while-reading note (quote, passage, thought)
       */
      async function addWhileReadingNote() {
        const book = ALL_BOOKS.find((b) => b.id === CURRENT_BOOK_ID);
        if (!book) return;

        const t = TRANSLATIONS[UI_LANGUAGE] || TRANSLATIONS.en;

        const pageNum = await showTextInputModal(
          `ğŸ“„ ${t.pageNumber} (${t.pageOptional.split("(")[1].split(")")[0]})`,
          t.pageOptional
        );

        if (pageNum === null) {
          showMessage("Cancelled", "info");
          return;
        }

        const noteText = await showTextInputModal(
          `ğŸ“ ${t.addNote}`,
          t.addNotePrompt
        );

        if (!noteText || noteText.trim() === "") {
          showMessage("Note cancelled", "info");
          return;
        }

        // Initialize whileReading array if it doesn't exist
        if (!book.whileReading) {
          book.whileReading = [];
        }

        book.whileReading.push({
          text: noteText.trim(),
          page: pageNum && pageNum.trim() ? pageNum.trim() : null,
          date: Date.now(),
        });

        book.updatedAt = Date.now();

        await saveBooks();
        viewBook(CURRENT_BOOK_ID);
        showMessage("Note added! ğŸ“", "success");
      }

      /**
       * Deletes a while-reading note
       * @param {number} index - Index of note to delete
       */
      async function deleteWhileReadingNote(index) {
        const book = ALL_BOOKS.find((b) => b.id === CURRENT_BOOK_ID);
        if (!book || !book.whileReading) return;

        if (!confirm("Delete this note?")) return;

        book.whileReading.splice(index, 1);
        book.updatedAt = Date.now();

        await saveBooks();
        viewBook(CURRENT_BOOK_ID);
        showMessage("Note deleted", "success");
      }

      /**
       * Deletes a book
       * @param {number} bookId - The book ID
       */
      async function deleteBook(bookId) {
        const book = ALL_BOOKS.find((b) => b.id === bookId);
        if (!book) return;

        if (!confirm(`Delete "${book.title}"? This cannot be undone.`)) {
          return;
        }

        ALL_BOOKS = ALL_BOOKS.filter((b) => b.id !== bookId);
        await saveBooks();
        displayBooks();
        showMessage("Book deleted", "success");
      }

      /**
       * Saves books to encrypted storage
       */
      async function saveBooks() {
        try {
          const booksData = JSON.stringify(ALL_BOOKS);
          const encryptedBooks = await encryptData(
            booksData,
            await deriveKey(
              CURRENT_PASSWORD,
              new TextEncoder().encode(CURRENT_USER.id)
            )
          );

          if (IS_LOCAL_MODE) {
            localStorage.setItem(
              `journal_books_${CURRENT_USER.id}`,
              encryptedBooks
            );
          } else {
            // Try Supabase, but fall back to localStorage if table doesn't exist
            try {
              const { error } = await supabase.from("journal_books").upsert({
                user_id: CURRENT_USER.id,
                encrypted_data: encryptedBooks,
              });

              if (error) {
                // If table doesn't exist (404), use localStorage instead
                console.log(
                  "Supabase table not found, using localStorage for books"
                );
                localStorage.setItem(
                  `journal_books_${CURRENT_USER.id}`,
                  encryptedBooks
                );
              }
            } catch (supabaseError) {
              // Fallback to localStorage
              console.log("Supabase error, using localStorage for books");
              localStorage.setItem(
                `journal_books_${CURRENT_USER.id}`,
                encryptedBooks
              );
            }
          }
        } catch (error) {
          console.error("Error saving books:", error);
          showMessage("Error saving books", "error");
        }
      }

      /**
       * Loads books from encrypted storage
       */
      async function loadBooks() {
        if (!CURRENT_PASSWORD || !CURRENT_USER) return;

        try {
          let encryptedData;

          if (IS_LOCAL_MODE) {
            encryptedData = localStorage.getItem(
              `journal_books_${CURRENT_USER.id}`
            );
          } else {
            // Try Supabase first, fall back to localStorage if table doesn't exist
            try {
              const { data, error } = await supabase
                .from("journal_books")
                .select("encrypted_data")
                .eq("user_id", CURRENT_USER.id)
                .limit(1);

              if (error) {
                // Table might not exist, check localStorage
                console.log(
                  "Supabase table not found, checking localStorage for books"
                );
                encryptedData = localStorage.getItem(
                  `journal_books_${CURRENT_USER.id}`
                );
              } else {
                encryptedData = data && data[0] ? data[0].encrypted_data : null;
                // If no data in Supabase, check localStorage
                if (!encryptedData) {
                  encryptedData = localStorage.getItem(
                    `journal_books_${CURRENT_USER.id}`
                  );
                }
              }
            } catch (supabaseError) {
              // Fallback to localStorage
              console.log("Supabase error, using localStorage for books");
              encryptedData = localStorage.getItem(
                `journal_books_${CURRENT_USER.id}`
              );
            }
          }

          if (!encryptedData) {
            ALL_BOOKS = [];
            return;
          }

          const decryptedData = await decryptData(
            encryptedData,
            await deriveKey(
              CURRENT_PASSWORD,
              new TextEncoder().encode(CURRENT_USER.id)
            )
          );
          ALL_BOOKS = JSON.parse(decryptedData);
        } catch (error) {
          console.log("Error loading books:", error);
          ALL_BOOKS = [];
        }
      }

      /**
       * Renders a list of entries (used by both loadEntries and filterEntries)
       */
      function renderEntries(entries) {
        const listElement = document.getElementById("entriesList");
        const noEntriesMessage = document.getElementById("noEntriesMessage");

        listElement.innerHTML = "";

        if (entries.length === 0) {
          noEntriesMessage.classList.remove("hidden");
          return;
        }

        noEntriesMessage.classList.add("hidden");

        // Render each entry
        entries.forEach((entry, index) => {
          const entryDiv = document.createElement("div");
          entryDiv.className =
            "entry-card p-4 border border-gray-200 rounded-lg dark:border-gray-600 dark:bg-gray-700";

          let editedHtml = "";
          if (entry.lastEdited) {
            editedHtml = `<span class="text-sm text-yellow-600 dark:text-yellow-400 font-semibold">(Edited: ${entry.lastEdited})</span>`;
          }

          // ğŸ”’ Privacy Mode: Determine if entry should be collapsed
          const isNewestEntry = index === 0;
          const isCollapsed =
            IMAGES_HIDDEN && !isNewestEntry && !COLLAPSED_ENTRIES.has(entry.id);

          // ğŸ“¸ Build images HTML with privacy mode support
          let imagesHtml = "";
          if (entry.images && entry.images.length > 0) {
            if (IMAGES_HIDDEN) {
              // Privacy mode: Show placeholder
              imagesHtml = `
                              <div class="mt-3 mb-3">
                                  <div id="images-placeholder-${
                                    entry.id
                                  }" class="bg-gray-100 dark:bg-gray-700 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-4 text-center cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition" onclick="showImagesForEntry(${
                entry.id
              })">
                                      <p class="text-gray-600 dark:text-gray-400">ğŸ–¼ï¸ ${
                                        entry.images.length
                                      } image(s) - Click to view</p>
                                  </div>
                                  <div id="images-${entry.id}" class="hidden">
                                      <div class="flex justify-between items-center mb-2">
                                          <span class="text-xs text-gray-500 dark:text-gray-400">${
                                            entry.images.length
                                          } image(s)</span>
                                      </div>
                                      <div class="grid grid-cols-2 md:grid-cols-3 gap-2">
                                          ${entry.images
                                            .map(
                                              (img, imgIndex) => `
                                              <div class="relative group">
                                                  <img src="${img.data}" alt="${
                                                img.name
                                              }" class="w-full h-32 object-cover rounded-lg border border-gray-300 dark:border-gray-600 cursor-pointer hover:opacity-90 transition" onclick="viewImageFullscreen('${
                                                img.data
                                              }')" title="${img.name}" />
                                                  <button onclick="deleteImageFromEntry(${
                                                    entry.id
                                                  }, ${imgIndex}); event.stopPropagation();" class="glow-btn absolute top-1 right-1 bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-700 opacity-0 group-hover:opacity-100 transition text-xs">Ã—</button>
                                                  ${
                                                    img.caption
                                                      ? `<p class="text-xs text-gray-600 dark:text-gray-400 mt-1 italic">${img.caption}</p>`
                                                      : ""
                                                  }
                                              </div>
                                          `
                                            )
                                            .join("")}
                                      </div>
                                  </div>
                              </div>
                          `;
            } else {
              // Normal mode: Show images directly
              imagesHtml = `
                              <div class="mt-3 mb-3">
                                  <div class="flex justify-between items-center mb-2">
                                      <span class="text-xs text-gray-500 dark:text-gray-400">${
                                        entry.images.length
                                      } image(s)</span>
                                  </div>
                                  <div class="grid grid-cols-2 md:grid-cols-3 gap-2">
                                      ${entry.images
                                        .map(
                                          (img, imgIndex) => `
                                          <div class="relative group">
                                              <img src="${img.data}" alt="${
                                            img.name
                                          }" class="w-full h-32 object-cover rounded-lg border border-gray-300 dark:border-gray-600 cursor-pointer hover:opacity-90 transition" onclick="viewImageFullscreen('${
                                            img.data
                                          }')" title="${img.name}" />
                                              <button onclick="deleteImageFromEntry(${
                                                entry.id
                                              }, ${imgIndex}); event.stopPropagation();" class="glow-btn absolute top-1 right-1 bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-700 opacity-0 group-hover:opacity-100 transition text-xs">Ã—</button>
                                              ${
                                                img.caption
                                                  ? `<p class="text-xs text-gray-600 dark:text-gray-400 mt-1 italic">${img.caption}</p>`
                                                  : ""
                                              }
                                          </div>
                                      `
                                        )
                                        .join("")}
                                  </div>
                              </div>
                          `;
            }
          }

          // ğŸ”’ Build collapsed/expanded view
          if (isCollapsed) {
            // Collapsed view: Show header only
            entryDiv.innerHTML = `
                          <div class="cursor-pointer" onclick="toggleEntryCollapse(${
                            entry.id
                          })">
                              <div class="flex justify-between items-center">
                                  <div>
                                      <p class="text-sm font-semibold text-indigo-600 dark:text-indigo-400">ğŸ“ ${
                                        entry.timestamp
                                      }</p>
                                      <p class="text-xs text-gray-500 dark:text-gray-400">${entry.text.substring(
                                        0,
                                        50
                                      )}${
              entry.text.length > 50 ? "..." : ""
            }</p>
                                      ${
                                        entry.images && entry.images.length > 0
                                          ? `<span class="text-xs text-gray-400">ğŸ–¼ï¸ ${entry.images.length} image(s)</span>`
                                          : ""
                                      }
                                      ${
                                        entry.voiceNote
                                          ? `<span class="text-xs text-pink-400">ğŸ¤ Voice note</span>`
                                          : ""
                                      }
                                  </div>
                                  <span class="text-gray-400">â–¼</span>
                              </div>
                          </div>
                      `;
          } else {
            // Expanded view: Show full entry
            const languageInfo = entry.language
              ? getLanguageInfo(entry.language)
              : null;
            const languageBadge = languageInfo
              ? `<span class="text-xs px-2 py-1 bg-gray-200 dark:bg-gray-600 rounded-full">${languageInfo.flag} ${languageInfo.name}</span>`
              : "";

            // ğŸ¤ Build voice note HTML
            let voiceNoteHtml = "";
            if (entry.voiceNote) {
              voiceNoteHtml = `
                <div class="mt-3 mb-3">
                  <div class="bg-pink-50 dark:bg-pink-900 border border-pink-300 dark:border-pink-700 rounded-lg p-3">
                    <div class="flex items-center gap-2 mb-2">
                      <span class="text-sm font-medium text-pink-700 dark:text-pink-300">ğŸ¤ Voice Note</span>
                      <span class="text-xs text-pink-600 dark:text-pink-400">(${Math.floor(
                        entry.voiceNote.duration / 60
                      )}:${(entry.voiceNote.duration % 60)
                .toString()
                .padStart(2, "0")})</span>
                    </div>
                    <audio controls class="w-full" src="${
                      entry.voiceNote.data
                    }"></audio>
                  </div>
                </div>
              `;
            }

            entryDiv.innerHTML = `
                          ${
                            IMAGES_HIDDEN && !isNewestEntry
                              ? `<div class="cursor-pointer mb-2" onclick="toggleEntryCollapse(${entry.id})"><span class="text-xs text-gray-400">â–² Collapse</span></div>`
                              : ""
                          }
                          <div class="flex justify-between items-start mb-2">
                              <div>
                                  <p class="text-xs font-mono text-gray-500 dark:text-gray-400">ID: ${
                                    entry.id
                                  } ${languageBadge}</p>
                                  <p class="text-sm font-semibold text-indigo-600 dark:text-indigo-400">${
                                    entry.timestamp
                                  }</p>
                                  ${editedHtml}
                              </div>
                              <div class="flex space-x-2">
                                  <button onclick="copyEntryToClipboard(${
                                    entry.id
                                  })" class="glow-btn text-sm text-green-500 hover:text-green-700 dark:text-green-400 dark:hover:text-green-200 transition" title="Copy to clipboard">ğŸ“‹ ${
              (TRANSLATIONS[UI_LANGUAGE] || TRANSLATIONS.en).copy
            }</button>
                                  <button onclick="manageEntryImages(${
                                    entry.id
                                  })" class="glow-btn text-sm text-blue-500 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-200 transition" title="Add/manage images">ğŸ–¼ï¸ ${
              (TRANSLATIONS[UI_LANGUAGE] || TRANSLATIONS.en).images
            }</button>
                                  <button onclick="openEditModal(${
                                    entry.id
                                  })" class="glow-btn text-sm text-blue-500 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-200 transition">âœï¸ ${
              (TRANSLATIONS[UI_LANGUAGE] || TRANSLATIONS.en).edit
            }</button>
                                  <button onclick="exportEntryToMarkdown(${
                                    entry.id
                                  })" class="glow-btn text-sm text-purple-500 hover:text-purple-700 dark:text-purple-400 dark:hover:text-purple-200 transition">ğŸ“„ ${
              (TRANSLATIONS[UI_LANGUAGE] || TRANSLATIONS.en).export
            }</button>
                                  <button onclick="deleteEntry(${
                                    entry.id
                                  })" class="glow-btn text-sm text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-200 transition">ğŸ—‘ï¸ ${
              (TRANSLATIONS[UI_LANGUAGE] || TRANSLATIONS.en).delete
            }</button>
                              </div>
                          </div>
                          <p class="text-gray-700 dark:text-gray-300 whitespace-pre-wrap">${
                            entry.text
                          }</p>
                          ${
                            entry.tags && entry.tags.length > 0
                              ? `
                              <div class="mt-3 mb-2 flex flex-wrap gap-2">
                                  ${renderTagBadges(entry.tags, true)}
                              </div>
                          `
                              : ""
                          }
                          ${imagesHtml}
                          ${voiceNoteHtml}
                      `;
          }

          listElement.appendChild(entryDiv);
        });
      }

      function applySavedTheme() {
        const savedTheme = localStorage.getItem("theme") || "light";
        const html = document.documentElement;
        const icon = document.getElementById("themeIcon");

        if (savedTheme === "dark") {
          html.classList.add("dark");
          icon.textContent = "ğŸŒ™";
        } else {
          html.classList.remove("dark");
          icon.textContent = "â˜€ï¸";
        }
      }

      // ========== VIEW SWITCHING ==========
      function setView(viewId) {
        const MANAGE_TAGS_VIEW = document.getElementById("manageTagsView");
        const BOOKS_VIEW = document.getElementById("booksView");
        const BOOK_DETAIL_VIEW = document.getElementById("bookDetailView");

        NEW_ENTRY_VIEW.classList.add("hidden");
        ENTRIES_LIST_VIEW.classList.add("hidden");
        if (MANAGE_TAGS_VIEW) MANAGE_TAGS_VIEW.classList.add("hidden");
        if (BOOKS_VIEW) BOOKS_VIEW.classList.add("hidden");
        if (BOOK_DETAIL_VIEW) BOOK_DETAIL_VIEW.classList.add("hidden");

        if (viewId === "new") {
          NEW_ENTRY_VIEW.classList.remove("hidden");
        } else if (viewId === "list") {
          ENTRIES_LIST_VIEW.classList.remove("hidden");
          loadEntries();
        } else if (viewId === "tags") {
          if (MANAGE_TAGS_VIEW) {
            MANAGE_TAGS_VIEW.classList.remove("hidden");
            displayTagManagement();
          }
        } else if (viewId === "books") {
          if (BOOKS_VIEW) {
            BOOKS_VIEW.classList.remove("hidden");
            displayBooks();
          }
        }
      }

      /**
       * Toggles the More menu dropdown
       */
      function toggleMoreMenu() {
        const dropdown = document.getElementById("moreMenuDropdown");
        dropdown.classList.toggle("hidden");
      }

      /**
       * Closes the More menu dropdown
       */
      function closeMoreMenu() {
        const dropdown = document.getElementById("moreMenuDropdown");
        dropdown.classList.add("hidden");
      }

      // Close dropdown when clicking outside
      document.addEventListener("click", (e) => {
        const moreBtn = document.getElementById("moreMenuBtn");
        const dropdown = document.getElementById("moreMenuDropdown");

        if (
          moreBtn &&
          dropdown &&
          !moreBtn.contains(e.target) &&
          !dropdown.contains(e.target)
        ) {
          closeMoreMenu();
        }
      });

      // ========== AUTHENTICATION ==========
      async function checkExistingAuth() {
        // If we recently forced a logout, skip auto-login
        if (localStorage.getItem("FORCED_LOGOUT")) {
          console.log("Skipping session restore due to forced logout.");
          localStorage.removeItem("FORCED_LOGOUT"); // Clear it immediately
          showAuthOptions();
          return;
        }

        // ğŸ”Œ Check if user is offline - offer local mode automatically
        if (!navigator.onLine) {
          console.log("No internet connection detected - offering local mode");
          const useLocal = confirm(
            "ğŸ“± NO INTERNET CONNECTION DETECTED\n\n" +
              "You appear to be offline. Would you like to use Local Mode?\n\n" +
              "Local Mode stores everything on this device only.\n\n" +
              "Click OK to use Local Mode, or Cancel to wait for connection."
          );

          if (useLocal) {
            useLocalMode();
            return;
          } else {
            showMessage("Waiting for internet connection...", "info");
            showAuthOptions();
            return;
          }
        }

        // Try to check Supabase session with timeout
        let session;
        try {
          const sessionPromise = supabase.auth.getSession();
          const timeoutPromise = new Promise((_, reject) =>
            setTimeout(() => reject(new Error("timeout")), 5000)
          );

          const { data } = await Promise.race([sessionPromise, timeoutPromise]);
          session = data.session;
        } catch (error) {
          console.log("Failed to reach Supabase:", error.message);

          // If we timeout or can't reach Supabase, offer local mode
          const useLocal = confirm(
            "âš ï¸ CANNOT REACH CLOUD SERVER\n\n" +
              "Unable to connect to the cloud. This might be due to:\n" +
              "â€¢ Weak internet connection\n" +
              "â€¢ Server temporarily unavailable\n\n" +
              "Would you like to use Local Mode instead?\n\n" +
              "Click OK for Local Mode, or Cancel to retry."
          );

          if (useLocal) {
            useLocalMode();
            return;
          } else {
            showAuthOptions();
            return;
          }
        }

        if (session) {
          // ğŸ”§ FIX: User is already signed in - go straight to journal
          console.log("Existing session found for:", session.user.email);
          CURRENT_USER = session.user;

          // Hide auth options if they're showing
          const authSection = document.getElementById("authSection");
          if (authSection) authSection.remove();

          // Show the journal interface
          NEW_ENTRY_VIEW.classList.remove("hidden");
          document.getElementById("signOutBtn").classList.remove("hidden");
          document.getElementById("privacyToggle").classList.remove("hidden");
          document
            .getElementById("languageSwitcher")
            .classList.remove("hidden");
          document.getElementById("mainNavigation").classList.remove("hidden"); // Show navigation

          // Load saved language preference
          const savedLang = localStorage.getItem("uiLanguage");
          if (savedLang) {
            UI_LANGUAGE = savedLang;
            document.getElementById("languageSwitcher").value = savedLang;
          }

          // Load saved privacy preference
          const savedPrivacy = localStorage.getItem("privacyMode");
          if (savedPrivacy !== null) {
            IMAGES_HIDDEN = savedPrivacy === "true";
            document.getElementById("privacyStatus").textContent = IMAGES_HIDDEN
              ? "ON"
              : "OFF";
          }

          showMessage("Welcome back! Unlocking journal...", "info");
          const unlocked = await initJournal(); // waits for user to unlock

          if (!unlocked) {
            // User cancelled - sign them out
            showMessage("Journal unlock cancelled. Signing out...", "error");
            await signOut();
            return;
          }

          document.querySelector("h1").textContent = "Secure Cloud Journal âœ“";
        } else {
          // No session - show login options
          console.log("No existing session - showing auth options");
          showAuthOptions();
        }
      }

      function showAuthOptions() {
        // Hide the journal interface while showing auth
        NEW_ENTRY_VIEW.classList.add("hidden");
        ENTRIES_LIST_VIEW.classList.add("hidden");
        document.getElementById("signOutBtn").classList.add("hidden");
        document.getElementById("mainNavigation").classList.add("hidden"); // Hide navigation

        // Check if auth section already exists
        let authSection = document.getElementById("authSection");
        if (authSection) {
          // Already exists, just make it visible
          authSection.classList.remove("hidden");
          return;
        }

        // Create auth section HTML
        const authHTML = `
                  <div id="authSection" class="card p-6 bg-white dark:bg-gray-800 rounded-xl shadow-xl mb-6">
                      <h2 class="text-2xl font-bold mb-4 text-gray-700 dark:text-gray-300">Cloud Journal</h2>
                      <p class="text-gray-600 dark:text-gray-400 mb-4">Sign in to sync across devices</p>
                      <div class="space-y-3">
                          <button onclick="signInWithEmail()" class="w-full px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition">Sign In</button>
                          <button onclick="signUpWithEmail()" class="w-full px-6 py-3 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition">Create Account</button>
                        <!-- ğŸŒ¿ Local Mode Button -->
                          <button onclick="useLocalMode()"
                              class="w-full px-6 py-3 bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-700 transition">
                          Use Local Mode
                      </button>
                  </div>
              </div>
          `;

        // Insert auth section at the beginning of journal-app (before messageBox)
        const journalApp = document.getElementById("journal-app");
        const messageBox = document.getElementById("messageBox");
        journalApp.insertBefore(createElementFromHTML(authHTML), messageBox);
      }

      // Helper function to create element from HTML string
      function createElementFromHTML(htmlString) {
        const div = document.createElement("div");
        div.innerHTML = htmlString.trim();
        return div.firstChild;
      }

      async function signInWithEmail() {
        // ğŸ†• Use custom modal for email (text input, no eye icon)
        const email = await showPasswordModal(
          "ğŸ“§ Sign In to Your Account",
          "Enter your Supabase account email address.",
          false,
          "Continue",
          "text" // Email is text, not password!
        );
        if (!email) return;

        // ğŸ†• Use custom modal for password (with eye icon)
        const password = await showPasswordModal(
          "ğŸ” Enter Your Password",
          "Enter your Supabase account password (not your journal passcode).",
          false,
          "Sign In",
          "password" // This is a password, show eye icon
        );
        if (!password) return;

        showMessage("Signing in...", "info");

        const { data, error } = await supabase.auth.signInWithPassword({
          email,
          password,
        });

        if (error) {
          showMessage("Sign in failed: " + error.message, "error");
        } else {
          CURRENT_USER = data.user;
          showMessage(
            "Successfully signed in as " + data.user.email,
            "success"
          );
          document.getElementById("authSection").remove();

          // ğŸ”§ FIX #4: Added journal unlock after sign-in
          const unlocked = await initJournal();
          if (!unlocked) return;

          NEW_ENTRY_VIEW.classList.remove("hidden");
          document.querySelector("h1").textContent = "Secure Cloud Journal âœ“";
          document.getElementById("signOutBtn").classList.remove("hidden");
          document.getElementById("privacyToggle").classList.remove("hidden");
          document.getElementById("mainNavigation").classList.remove("hidden"); // Show navigation

          // Load saved privacy preference
          const savedPrivacy = localStorage.getItem("privacyMode");
          if (savedPrivacy !== null) {
            IMAGES_HIDDEN = savedPrivacy === "true";
            document.getElementById("privacyStatus").textContent = IMAGES_HIDDEN
              ? "ON"
              : "OFF";
          }
        }
      }

      async function signUpWithEmail() {
        // ğŸ”’ SECURITY WARNING: Inform user about account creation
        const warningMessage = `âš ï¸ ACCOUNT SECURITY NOTICE âš ï¸

      You're about to create a cloud-synced journal account.

      IMPORTANT REMINDERS:
      â€¢ Your Supabase password lets you log in
      â€¢ Your encryption passcode protects your entries
      â€¢ These are TWO DIFFERENT passwords
      â€¢ If you forget your encryption passcode, your entries cannot be recovered
      â€¢ Write down your passcode somewhere safe!

      Click OK to continue with account creation.`;

        if (!confirm(warningMessage)) {
          return; // User clicked Cancel
        }

        // ğŸ†• Use custom modal for email (text input)
        const email = await showPasswordModal(
          "ğŸ“§ Create Your Account",
          "Enter your email address for your journal account.",
          false,
          "Continue",
          "text" // Email is text!
        );
        if (!email) return;

        // ğŸ†• Use custom modal for password with confirmation
        const password = await showPasswordModal(
          "ğŸ” Create Account Password",
          "Create a strong password (minimum 6 characters). This is your Supabase login password, NOT your journal encryption passcode.",
          true, // Require confirmation!
          "Create Account",
          "password" // This is a password with eye icons
        );
        if (!password) return;

        if (password.length < 6) {
          showMessage("Password must be at least 6 characters", "error");
          return;
        }

        showMessage("Creating account...", "info");

        const { data, error } = await supabase.auth.signUp({ email, password });

        if (error) {
          showMessage("Sign up failed: " + error.message, "error");
        } else {
          showMessage(
            "Account created! Please check your email for verification.",
            "success"
          );
          setTimeout(() => signInWithEmail(), 3000);
        }
      }

      function useLocalMode() {
        // ğŸ”’ WARNING: Local mode limitations
        const localModeWarning = `
      ğŸ“± LOCAL MODE (OFFLINE)

      You're about to use Local Mode:

      HOW IT WORKS:
      â€¢ All data stored ONLY on this device
      â€¢ Nothing syncs to the cloud
      â€¢ If you clear browser data, everything is lost
      â€¢ Cannot access from other devices

      SECURITY REMINDER:
      â€¢ You'll still need an encryption passcode
      â€¢ Passcode cannot be reset
      â€¢ Write it down somewhere safe!

      Continue with Local Mode?
          `;

        if (!confirm(localModeWarning.trim())) {
          return;
        }

        IS_LOCAL_MODE = true;
        CURRENT_USER = { id: "local" };

        // ğŸ”§ FIX: Hide auth section and show journal interface
        const authSection = document.getElementById("authSection");
        if (authSection) authSection.remove();

        NEW_ENTRY_VIEW.classList.remove("hidden");
        document.querySelector("h1").textContent = "Secure Local Journal ğŸ”’";

        // Show navigation
        document.getElementById("mainNavigation").classList.remove("hidden");

        // Show sign out button (but change text for local mode)
        const signOutBtn = document.getElementById("signOutBtn");
        signOutBtn.textContent = "Switch Mode";
        signOutBtn.classList.remove("hidden");

        // Show privacy toggle
        document.getElementById("privacyToggle").classList.remove("hidden");

        // Load saved privacy preference
        const savedPrivacy = localStorage.getItem("privacyMode");
        if (savedPrivacy !== null) {
          IMAGES_HIDDEN = savedPrivacy === "true";
          document.getElementById("privacyStatus").textContent = IMAGES_HIDDEN
            ? "ON"
            : "OFF";
        }

        showMessage("Offline mode enabled", "info");
        initJournal(); // prompts for the passcode
      }

      async function signOut() {
        // Check if in local mode
        if (IS_LOCAL_MODE) {
          // Local mode: just reload to go back to auth screen
          CURRENT_USER = null;
          CURRENT_PASSWORD = null;
          IS_LOCAL_MODE = false;
          showMessage("Switching modes...", "info");
          setTimeout(() => {
            location.reload();
          }, 500);
          return;
        }

        // Cloud mode: sign out from Supabase
        localStorage.setItem("FORCED_LOGOUT", "1");

        const { error } = await supabase.auth.signOut();
        if (error) {
          console.error("Sign out failed:", error.message);
          showMessage("Sign out failed", "error");
          return;
        }

        CURRENT_USER = null;
        CURRENT_PASSWORD = null;
        showMessage("Signed out successfully", "success");

        // Reload page to show auth options
        setTimeout(() => {
          location.reload();
        }, 500);
      }

      // ========== JOURNAL CORE FUNCTIONS ==========
      async function initJournal() {
        // Check if this user already has encrypted data (returning user)
        let isReturningUser = false;

        if (IS_LOCAL_MODE) {
          // ğŸ”§ FIX: Check localStorage for local mode
          const localData = localStorage.getItem(
            `journal_entries_${CURRENT_USER.id}`
          );
          isReturningUser = localData !== null && localData.length > 0;
          console.log("Local mode check - isReturningUser:", isReturningUser);
        } else {
          // Check Supabase for cloud mode
          const { data: existingData } = await supabase
            .from("journal_entries")
            .select("encrypted_data")
            .eq("user_id", CURRENT_USER.id)
            .limit(1);

          isReturningUser = existingData && existingData.length > 0;
          console.log("Cloud mode check - isReturningUser:", isReturningUser);
        }

        if (!isReturningUser) {
          // ğŸ†• NEW USER: Hybrid System

          // Step 1: Generate 12-word backup phrase
          const confirmed = await showRecoveryPhraseModal();

          if (!confirmed) {
            showMessage(
              "Journal setup cancelled. Refresh to try again.",
              "error"
            );
            return false;
          }

          // Store the recovery phrase temporarily
          const recoveryPhrase = [...currentRecoveryPhrase];

          // Step 2: Ask user to create a SHORT passcode for daily use
          const dailyPasscode = await showPasswordModal(
            "ğŸ” Create Daily Passcode",
            "Now create a SHORT passcode for daily use (4-20 characters). This is what you'll type each time you unlock your journal.\n\nYour 12-word phrase is your BACKUP if you forget this passcode.",
            true, // Confirm it
            "Create Passcode",
            "password"
          );

          if (!dailyPasscode) {
            showMessage("Journal setup cancelled.", "error");
            return false;
          }

          if (dailyPasscode.length < 4) {
            showMessage("Passcode must be at least 4 characters.", "error");
            return false;
          }

          // Use the daily passcode as the encryption key
          CURRENT_PASSWORD = dailyPasscode;

          // Store the recovery phrase â†’ passcode mapping in localStorage
          // (Recovery phrase hashed so we can verify it later)
          const recoveryHash = await phraseToPasscode(recoveryPhrase);
          localStorage.setItem(
            `recovery_${CURRENT_USER.id}`,
            JSON.stringify({
              phraseHash: recoveryHash,
              passcode: dailyPasscode,
            })
          );

          currentRecoveryPhrase = null; // Clear from memory

          showMessage(
            "âœ… Journal setup complete! Use your short passcode daily.",
            "success"
          );
        } else {
          // ğŸ”„ RETURNING USER: Two options

          // Show choice: Regular passcode or recovery phrase?
          const choice = confirm(
            "Unlock with your regular passcode?\n\nClick OK for regular passcode\nClick Cancel to use 12-word recovery phrase"
          );

          if (choice) {
            // Option A: Regular daily passcode
            const passcode = await showPasswordModal(
              "ğŸ” Unlock Your Journal",
              "Enter your daily passcode.",
              false,
              "Unlock",
              "password"
            );

            if (!passcode) {
              showMessage("Journal locked.", "error");
              return false;
            }

            CURRENT_PASSWORD = passcode;
          } else {
            // Option B: Recovery phrase
            const phraseInput = await showPasswordModal(
              "ğŸ”‘ Enter Recovery Phrase",
              "Enter your 12-word recovery phrase (separated by spaces).",
              false,
              "Recover",
              "text"
            );

            if (!phraseInput) {
              showMessage("Journal locked.", "error");
              return false;
            }

            // Parse and validate
            const words = phraseInput.trim().toLowerCase().split(/\s+/);

            if (!validateRecoveryPhrase(words)) {
              showMessage(
                "Invalid recovery phrase. Check your words and try again.",
                "error"
              );
              return false;
            }

            // Check if we have the mapping stored
            const recoveryData = localStorage.getItem(
              `recovery_${CURRENT_USER.id}`
            );
            if (recoveryData) {
              const { phraseHash, passcode } = JSON.parse(recoveryData);
              const inputHash = await phraseToPasscode(words);

              if (inputHash === phraseHash) {
                // Recovery phrase matches! Use stored passcode
                CURRENT_PASSWORD = passcode;
                showMessage(
                  "âœ… Recovered! Consider writing down your passcode.",
                  "success"
                );
              } else {
                showMessage(
                  "Recovery phrase doesn't match your account.",
                  "error"
                );
                return false;
              }
            } else {
              // Fallback: Use phrase as passcode (for old accounts)
              CURRENT_PASSWORD = await phraseToPasscode(words);
            }
          }
        }

        await loadEntries();
        await loadBooks(); // ğŸ“š Load books data
        return true;
      }

      // ========== ğŸ¤ VOICE NOTE FUNCTIONS ==========

      /**
       * Toggles voice recording on/off
       */
      async function toggleVoiceRecording() {
        if (isRecording) {
          // Stop recording
          stopVoiceRecording();
        } else {
          // Start recording
          await startVoiceRecording();
        }
      }

      /**
       * Starts voice recording
       */
      async function startVoiceRecording() {
        try {
          // Request microphone permission
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });

          // Create media recorder
          mediaRecorder = new MediaRecorder(stream);
          audioChunks = [];

          mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
          };

          mediaRecorder.onstop = async () => {
            // Create audio blob
            const audioBlob = new Blob(audioChunks, { type: "audio/webm" });

            // Convert to base64
            const reader = new FileReader();
            reader.onloadend = () => {
              const base64Audio = reader.result;
              const duration = Math.floor(
                (Date.now() - recordingStartTime) / 1000
              );

              CURRENT_VOICE_NOTE = {
                data: base64Audio,
                duration: duration,
                type: "audio/webm",
              };

              showVoiceNotePreview();
            };
            reader.readAsDataURL(audioBlob);

            // Stop all tracks
            stream.getTracks().forEach((track) => track.stop());
          };

          // Start recording
          mediaRecorder.start();
          isRecording = true;
          recordingStartTime = Date.now();

          // Update button
          const btn = document.getElementById("recordVoiceBtn");
          const btnText = document.getElementById("recordVoiceBtnText");
          btn.classList.remove("bg-pink-600", "hover:bg-pink-700");
          btn.classList.add("bg-red-600", "hover:bg-red-700", "animate-pulse");
          btnText.textContent = "â¹ï¸ Stop Recording";

          showMessage("ğŸ¤ Recording... Click again to stop", "info");
        } catch (error) {
          console.error("Error starting recording:", error);
          showMessage(
            "âŒ Could not access microphone. Please allow microphone access.",
            "error"
          );
        }
      }

      /**
       * Stops voice recording
       */
      function stopVoiceRecording() {
        if (mediaRecorder && isRecording) {
          mediaRecorder.stop();
          isRecording = false;

          // Update button
          const btn = document.getElementById("recordVoiceBtn");
          const btnText = document.getElementById("recordVoiceBtnText");
          btn.classList.remove(
            "bg-red-600",
            "hover:bg-red-700",
            "animate-pulse"
          );
          btn.classList.add("bg-pink-600", "hover:bg-pink-700");
          btnText.textContent = "Record Voice Note";

          showMessage("âœ… Voice note saved!", "success");
        }
      }

      /**
       * Shows voice note preview
       */
      function showVoiceNotePreview() {
        const preview = document.getElementById("voiceNotePreview");
        const player = document.getElementById("voiceNotePlayer");
        const durationSpan = document.getElementById("voiceNoteDuration");

        if (CURRENT_VOICE_NOTE) {
          player.src = CURRENT_VOICE_NOTE.data;

          // Format duration
          const minutes = Math.floor(CURRENT_VOICE_NOTE.duration / 60);
          const seconds = CURRENT_VOICE_NOTE.duration % 60;
          durationSpan.textContent = `${minutes}:${seconds
            .toString()
            .padStart(2, "0")}`;

          preview.classList.remove("hidden");
        }
      }

      /**
       * Deletes current voice note
       */
      function deleteVoiceNote() {
        if (confirm("Delete this voice note?")) {
          CURRENT_VOICE_NOTE = null;
          document.getElementById("voiceNotePreview").classList.add("hidden");
          showMessage("Voice note deleted", "info");
        }
      }

      /**
       * Clears current voice note (after saving)
       */
      function clearCurrentVoiceNote() {
        CURRENT_VOICE_NOTE = null;
        document.getElementById("voiceNotePreview").classList.add("hidden");
      }

      // ========== ENTRY SAVING & LOADING ==========

      async function saveEntry() {
        const text = JOURNAL_INPUT.value.trim();
        if (!text || !CURRENT_PASSWORD) {
          showMessage("Entry cannot be empty or journal is locked.", "error");
          return;
        }

        try {
          animateSaveStatus("saving");
          console.log("=== SAVE ENTRY DEBUG ===");

          // ğŸ·ï¸ Extract tags from both the tag input field and the entry text
          const tags = extractTags();

          // ğŸŒ Get selected entry language
          const entryLanguage = document.getElementById("entryLanguage").value;

          const now = Date.now();
          const newEntry = {
            id: now,
            timestamp: new Date(now).toLocaleString(),
            text: text,
            lastEdited: null,
            images: CURRENT_IMAGES.length > 0 ? [...CURRENT_IMAGES] : [], // ğŸ“¸ Include images
            voiceNote: CURRENT_VOICE_NOTE ? { ...CURRENT_VOICE_NOTE } : null, // ğŸ¤ Include voice note
            tags: tags, // ğŸ·ï¸ Include tags
            language: entryLanguage, // ğŸŒ Include entry language
          };
          console.log("New entry created:", newEntry);
          console.log("Images attached:", CURRENT_IMAGES.length);
          console.log(
            "Voice note attached:",
            CURRENT_VOICE_NOTE ? "Yes" : "No"
          );
          console.log("Tags attached:", tags);
          console.log("Language:", entryLanguage);

          console.log("Fetching existing entries before save...");
          let entries = await getDecryptedEntries();
          console.log("Existing entries count:", entries.length);

          entries.push(newEntry);
          console.log("Total entries after adding new one:", entries.length);

          await saveEncryptedEntries(entries);
          animateSaveStatus("saved");

          JOURNAL_INPUT.value = "";
          clearCurrentImages(); // ğŸ“¸ Clear images after saving
          clearCurrentVoiceNote(); // ğŸ¤ Clear voice note after saving
          clearCurrentTags(); // ğŸ·ï¸ Clear tags after saving
          showMessage("Entry securely saved!", "success");
          loadEntries();
          updateSaveStatus();
        } catch (error) {
          console.error("Error in saveEntry:", error);
          showMessage("Error saving entry.", "error");
          animateSaveStatus("error");
        }
      }

      // ========== ENCRYPTION/DECRYPTION ==========
      // ğŸ”§ FIX #3: Removed duplicate functions - keeping only one set
      async function deriveKey(password, salt) {
        const encodedPassword = new TextEncoder().encode(password);
        const keyMaterial = await crypto.subtle.importKey(
          "raw",
          encodedPassword,
          { name: "PBKDF2" },
          false,
          ["deriveKey"]
        );
        return crypto.subtle.deriveKey(
          { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
          keyMaterial,
          { name: "AES-GCM", length: 256 },
          true,
          ["encrypt", "decrypt"]
        );
      }

      async function encryptData(data, key) {
        const encodedData = new TextEncoder().encode(data);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encryptedContent = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv },
          key,
          encodedData
        );
        const fullEncrypted = new Uint8Array(
          iv.length + encryptedContent.byteLength
        );
        fullEncrypted.set(iv, 0);
        fullEncrypted.set(new Uint8Array(encryptedContent), iv.length);

        // ğŸ”§ FIX: Process in chunks to avoid stack overflow with large data
        let binary = "";
        const chunkSize = 8192; // Process 8KB at a time
        for (let i = 0; i < fullEncrypted.length; i += chunkSize) {
          const chunk = fullEncrypted.subarray(
            i,
            Math.min(i + chunkSize, fullEncrypted.length)
          );
          binary += String.fromCharCode.apply(null, chunk);
        }
        return btoa(binary);
      }

      async function decryptData(encryptedB64, key) {
        try {
          // ğŸ”§ FIX: Process base64 decoding safely for large data
          const binaryString = atob(encryptedB64);
          const fullEncrypted = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            fullEncrypted[i] = binaryString.charCodeAt(i);
          }

          const iv = fullEncrypted.slice(0, 12);
          const ciphertext = fullEncrypted.slice(12);
          const decryptedContent = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv },
            key,
            ciphertext
          );
          return new TextDecoder().decode(decryptedContent);
        } catch (error) {
          console.error("Decryption failed:", error);
          throw new Error("Invalid password or corrupt data.");
        }
      }

      async function getDecryptedEntries() {
        console.log("=== GET DECRYPTED ENTRIES DEBUG ===");
        console.log("CURRENT_USER object:", CURRENT_USER);
        console.log("Local mode:", IS_LOCAL_MODE);

        if (!CURRENT_PASSWORD || !CURRENT_USER) {
          console.log("Missing password or user");
          return [];
        }

        try {
          let encryptedData;

          // ğŸ†• LOCAL MODE: Load from localStorage
          if (IS_LOCAL_MODE) {
            console.log("Loading from localStorage...");
            encryptedData = localStorage.getItem(
              `journal_entries_${CURRENT_USER.id}`
            );

            if (!encryptedData) {
              console.log(
                "No data in localStorage yet (new user) - returning empty array"
              );
              return [];
            }

            console.log("Found encrypted data in localStorage");
          } else {
            // ğŸ”§ CLOUD MODE: Load from Supabase
            console.log("Fetching from Supabase for user:", CURRENT_USER.id);

            const { data, error } = await supabase
              .from("journal_entries")
              .select("encrypted_data")
              .eq("user_id", CURRENT_USER.id)
              .limit(1);

            console.log("Supabase response - data:", data, "error:", error);

            if (error) {
              console.error("Error from Supabase:", error);
              return [];
            }

            // Check if data is empty array (no entries yet)
            if (!data || data.length === 0) {
              console.log(
                "No data from Supabase yet (new user) - returning empty array"
              );
              return [];
            }

            encryptedData = data[0].encrypted_data;
            console.log("Found encrypted data from Supabase");
          }

          // Decrypt the data (same for both modes)
          console.log("Attempting decryption...");
          console.log(
            "Encrypted data sample (first 50 chars):",
            encryptedData.substring(0, 50)
          );

          const salt = new TextEncoder().encode(CURRENT_USER.id);
          const key = await deriveKey(CURRENT_PASSWORD, salt);

          const decryptedJson = await decryptData(encryptedData, key);
          console.log("Decryption successful!");

          const entries = JSON.parse(decryptedJson);
          console.log("Parsed entries count:", entries.length);
          return entries;
        } catch (error) {
          console.error("Error in getDecryptedEntries:", error);
          console.error("Full error details:", error.message, error.stack);

          // ğŸ”’ CRITICAL: If we have encrypted data but decryption failed,
          // it's likely a WRONG PASSCODE - DO NOT return empty array!
          if (encryptedData) {
            console.error(
              "WRONG PASSCODE - Decryption failed but data exists!"
            );
            showMessage(
              "âŒ Incorrect passcode! Your data is safe but locked.",
              "error"
            );

            // Clear the wrong password and force re-entry
            CURRENT_PASSWORD = null;

            // Ask for passcode again
            setTimeout(async () => {
              const newPassword = await showPasswordModal(
                "ğŸ” Enter Passcode",
                "The passcode you entered was incorrect. Please try again.",
                false,
                "Unlock"
              );

              if (newPassword) {
                CURRENT_PASSWORD = newPassword;
                loadEntries(); // Try again with correct password
              }
            }, 100);

            throw new Error("Incorrect passcode");
          }

          // If no encrypted data exists, return empty array (new user)
          return [];
        }
      }

      // ========== ENTRY DISPLAY & EDITING ==========
      async function loadEntries() {
        console.log("ğŸš€ loadEntries called ONCE");

        if (!CURRENT_PASSWORD) {
          console.log("No password - returning early");
          return;
        }

        try {
          console.log("Getting decrypted entries...");
          let entries = await getDecryptedEntries();
          console.log("Retrieved entries:", entries);

          // Sort by newest first
          entries.sort((a, b) => b.id - a.id);

          // Store for filtering
          ALL_ENTRIES = entries;

          // ğŸ·ï¸ Collect all tags for suggestions (Phase 5.2)
          collectAllTags(entries);

          renderTagButtons(COLLECTED_TAGS);

          // ğŸ·ï¸ Update filter display (Phase 5.3)
          updateTagFilterDisplay();

          updateTagButtonVisibility();

          // Render entries
          renderEntries(entries);
        } catch (error) {
          // Don't show generic message if it's a passcode error
          if (error.message !== "Incorrect passcode") {
            showMessage("Could not load entries.", "error");
          }
        }
      }

      async function deleteEntry(id) {
        if (!confirm("Are you sure you want to delete this entry?")) return;

        try {
          let entries = await getDecryptedEntries();
          const initialLength = entries.length;
          entries = entries.filter((entry) => entry.id !== id);

          if (entries.length < initialLength) {
            await saveEncryptedEntries(entries);
            showMessage("Entry deleted successfully.", "success");
            loadEntries();
          }
        } catch (error) {
          showMessage("Error deleting entry.", "error");
        }
      }

      /**
       * Deletes a specific image from an entry
       */
      async function deleteImageFromEntry(entryId, imageIndex) {
        if (!confirm("Delete this image?")) return;

        try {
          let entries = await getDecryptedEntries();
          const entry = entries.find((e) => e.id === entryId);

          if (!entry || !entry.images) {
            showMessage("Entry or images not found.", "error");
            return;
          }

          // Remove the image at the specified index
          entry.images.splice(imageIndex, 1);

          // Update last edited timestamp
          entry.lastEdited = new Date().toLocaleString();

          await saveEncryptedEntries(entries);
          showMessage("Image deleted successfully.", "success");
          loadEntries();
        } catch (error) {
          console.error("Error deleting image:", error);
          showMessage("Error deleting image.", "error");
        }
      }

      /**
       * Opens a modal to manage images in an entry (add more images)
       */
      async function manageEntryImages(entryId) {
        try {
          const entries = await getDecryptedEntries();
          const entry = entries.find((e) => e.id === entryId);

          if (!entry) {
            showMessage("Entry not found.", "error");
            return;
          }

          // Create file input for adding images
          const input = document.createElement("input");
          input.type = "file";
          input.accept = "image/*";
          input.multiple = true;

          input.onchange = async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            showMessage("Compressing and adding images...", "info");

            // Initialize images array if it doesn't exist
            if (!entry.images) entry.images = [];

            let successCount = 0;
            for (const file of files) {
              if (!file.type.startsWith("image/")) continue;

              try {
                const compressedBase64 = await compressImage(file, 1920, 0.85);

                entry.images.push({
                  name: file.name,
                  data: compressedBase64,
                  type: "image/jpeg",
                });
                successCount++;
              } catch (error) {
                console.error(`Failed to add ${file.name}:`, error);
              }
            }

            if (successCount > 0) {
              entry.lastEdited = new Date().toLocaleString();
              await saveEncryptedEntries(entries);
              showMessage(
                `Added ${successCount} image(s) to entry! ğŸ“¸`,
                "success"
              );
              loadEntries();
            } else {
              showMessage("No images were added.", "error");
            }
          };

          input.click();
        } catch (error) {
          console.error("Error managing images:", error);
          showMessage("Error managing images.", "error");
        }
      }

      async function copyEntryToClipboard(id) {
        try {
          const entries = await getDecryptedEntries();
          const entry = entries.find((e) => e.id === id);

          if (!entry) {
            showMessage("Entry not found.", "error");
            return;
          }

          // Create formatted text with timestamp
          const formattedText = `${entry.timestamp}\n\n${entry.text}`;

          // Copy to clipboard
          await navigator.clipboard.writeText(formattedText);

          showMessage("Entry copied to clipboard! ğŸ“‹", "success");
        } catch (error) {
          showMessage(
            "Failed to copy entry. Your browser might not support clipboard access.",
            "error"
          );
          console.error("Copy failed:", error);
        }
      }

      async function openEditModal(id) {
        if (!CURRENT_PASSWORD) return;
        try {
          const entries = await getDecryptedEntries();
          const entry = entries.find((e) => e.id === id);

          if (entry) {
            EDITING_ENTRY_ID = id;
            document.getElementById("editModalId").textContent = `ID: ${id}`;
            document.getElementById("editModalInput").value = entry.text;
            EDIT_MODAL.classList.remove("hidden");
            EDIT_MODAL.classList.add("flex");
          }
        } catch (error) {
          showMessage("Error loading entry for edit.", "error");
        }
      }

      function closeEditModal() {
        EDITING_ENTRY_ID = null;
        EDIT_MODAL.classList.add("hidden");
        EDIT_MODAL.classList.remove("flex");
      }

      async function confirmEdit() {
        if (!EDITING_ENTRY_ID || !CURRENT_PASSWORD) return;

        const newText = document.getElementById("editModalInput").value.trim();
        if (!newText) {
          showMessage("Edited text cannot be empty.", "error");
          return;
        }

        try {
          let entries = await getDecryptedEntries();
          const index = entries.findIndex((e) => e.id === EDITING_ENTRY_ID);

          if (index !== -1) {
            entries[index].text = newText;
            entries[index].lastEdited = new Date().toLocaleString();
            await saveEncryptedEntries(entries);
            showMessage(`Entry updated successfully.`, "success");
            closeEditModal();
            loadEntries();
          }
        } catch (error) {
          showMessage("Error saving edited entry.", "error");
        }
      }

      async function saveEncryptedEntries(entries) {
        if (!CURRENT_PASSWORD || !CURRENT_USER) {
          showMessage("Cannot save: no user or password set.", "error");
          return;
        }

        try {
          // Convert entries array to JSON string
          const jsonString = JSON.stringify(entries);
          const sizeMB = (jsonString.length / 1024 / 1024).toFixed(2);

          console.log("=== SAVE ENCRYPTED ENTRIES DEBUG ===");
          console.log("Saving", entries.length, "entries");
          console.log("JSON size:", sizeMB, "MB");
          console.log("Local mode:", IS_LOCAL_MODE);

          // Check size limits
          if (IS_LOCAL_MODE && jsonString.length > 5 * 1024 * 1024) {
            showMessage(
              `âš ï¸ Data too large (${sizeMB}MB). LocalStorage limit is ~5MB. Try removing some images.`,
              "error"
            );
            return;
          }

          // Derive key and encrypt
          const salt = new TextEncoder().encode(CURRENT_USER.id);
          const key = await deriveKey(CURRENT_PASSWORD, salt);
          const encryptedData = await encryptData(jsonString, key);

          console.log(
            "Encryption successful, encrypted size:",
            (encryptedData.length / 1024 / 1024).toFixed(2),
            "MB"
          );

          // ğŸ†• LOCAL MODE: Save to localStorage
          if (IS_LOCAL_MODE) {
            try {
              localStorage.setItem(
                `journal_entries_${CURRENT_USER.id}`,
                encryptedData
              );
              console.log("Successfully saved to localStorage");
            } catch (storageError) {
              console.error("localStorage error:", storageError);
              if (storageError.name === "QuotaExceededError") {
                showMessage(
                  "Storage quota exceeded! Your images are too large for local mode. Try using cloud mode or smaller images.",
                  "error"
                );
              } else {
                showMessage(
                  "Failed to save to localStorage: " + storageError.message,
                  "error"
                );
              }
              throw storageError;
            }
            return;
          }

          // ğŸ”§ CLOUD MODE: Save to Supabase
          const { data, error } = await supabase
            .from("journal_entries")
            .upsert(
              {
                user_id: CURRENT_USER.id,
                encrypted_data: encryptedData,
              },
              {
                onConflict: "user_id",
              }
            )
            .select();

          if (error) {
            console.error("Error saving encrypted entries:", error);
            showMessage("Failed to save entry: " + error.message, "error");
            return;
          }

          console.log("Successfully saved to Supabase:", data);
        } catch (err) {
          console.error("Error in saveEncryptedEntries:", err);
          console.error("Error name:", err.name);
          console.error("Error message:", err.message);
          console.error("Error stack:", err.stack);
          showMessage("Failed to save entry: " + err.message, "error");
        }
      }

      // ========== PASSCODE CHANGE ==========
      async function changePasscode() {
        if (!CURRENT_PASSWORD) {
          showMessage("Please unlock journal first.", "error");
          return;
        }

        // ğŸ”’ WARNING: Changing passcode
        const changeWarning = `
      âš ï¸ CHANGE ENCRYPTION PASSCODE âš ï¸

      You're about to change your journal encryption passcode.

      IMPORTANT:
      â€¢ You'll need to enter your CURRENT passcode first
      â€¢ Then create a NEW passcode
      â€¢ All existing entries will be re-encrypted with the new passcode
      â€¢ Make sure you WRITE DOWN your new passcode
      â€¢ You CANNOT recover your entries if you forget the new passcode

      Do you want to continue?
              `;

        if (!confirm(changeWarning.trim())) {
          return;
        }

        const oldPass = prompt("Enter your CURRENT passcode:");
        if (oldPass !== CURRENT_PASSWORD) {
          showMessage("Incorrect current passcode.", "error");
          return;
        }

        const newPass = prompt("Enter your NEW passcode:");
        if (!newPass || newPass.length < 4) {
          showMessage("New passcode must be at least 4 characters.", "error");
          return;
        }

        const confirmPass = prompt("Confirm your NEW passcode:");
        if (newPass !== confirmPass) {
          showMessage("Passcodes do not match.", "error");
          return;
        }

        try {
          // Get current entries with old password
          const entries = await getDecryptedEntries();

          // Update password
          CURRENT_PASSWORD = newPass;

          // Re-encrypt with new password
          await saveEncryptedEntries(entries);

          // ğŸ”’ Success reminder
          const successReminder = `
      âœ… Passcode changed successfully!

      REMINDER: Write down your new passcode NOW:
      â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      Store it somewhere safe. This is your ONLY way to access your journal.
      â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                  `;

          alert(successReminder.trim());
          showMessage("Passcode changed successfully!", "success");
        } catch (error) {
          showMessage("Error changing passcode.", "error");
          CURRENT_PASSWORD = oldPass; // Restore old password on error
        }
      }

      // ========== MARKDOWN EXPORT ==========
      async function exportEntryToMarkdown(entryId) {
        if (!CURRENT_PASSWORD) return;

        try {
          const entries = await getDecryptedEntries();
          const entry = entries.find((e) => e.id === entryId);

          if (entry) {
            const markdownContent = `# ${entry.timestamp}\n\n${entry.text}\n\n---\n*Journal ID: ${entryId}*`;
            downloadAsFile(
              markdownContent,
              `journal-entry-${entryId}.md`,
              "text/markdown"
            );
            showMessage("Entry exported as Markdown!", "success");
          }
        } catch (error) {
          showMessage("Error exporting entry", "error");
        }
      }

      async function exportAllToMarkdown() {
        if (!CURRENT_PASSWORD) return;

        try {
          const entries = await getDecryptedEntries();
          let markdownContent = `# Journal Export\n*Generated on ${new Date().toLocaleString()}*\n\n`;

          entries
            .sort((a, b) => b.id - a.id)
            .forEach((entry) => {
              markdownContent += `## ${entry.timestamp}\n\n${entry.text}\n\n---\n\n`;
            });

          downloadAsFile(
            markdownContent,
            `journal-export-${Date.now()}.md`,
            "text/markdown"
          );
          showMessage("All entries exported as Markdown!", "success");
        } catch (error) {
          showMessage("Error exporting entries", "error");
        }
      }

      /**
       * ğŸ“„ Exports all journal entries as a PDF
       */
      async function exportAllToPDF() {
        if (!CURRENT_PASSWORD) return;

        try {
          showMessage("Generating PDF... Please wait", "info");

          const entries = await getDecryptedEntries();
          const { jsPDF } = window.jspdf;
          const doc = new jsPDF();

          // PDF Settings
          const pageWidth = doc.internal.pageSize.getWidth();
          const pageHeight = doc.internal.pageSize.getHeight();
          const margin = 20;
          const maxWidth = pageWidth - margin * 2;
          let yPosition = margin;

          // Title
          doc.setFontSize(20);
          doc.setFont(undefined, "bold");
          doc.text("Journal Export", margin, yPosition);
          yPosition += 10;

          // Generated date
          doc.setFontSize(10);
          doc.setFont(undefined, "normal");
          doc.setTextColor(100);
          doc.text(
            `Generated on ${new Date().toLocaleString()}`,
            margin,
            yPosition
          );
          yPosition += 15;
          doc.setTextColor(0);

          // Sort entries newest first
          const sortedEntries = entries.sort((a, b) => b.id - a.id);

          // Add each entry
          sortedEntries.forEach((entry, index) => {
            // Check if we need a new page
            if (yPosition > pageHeight - 40) {
              doc.addPage();
              yPosition = margin;
            }

            // Entry timestamp
            doc.setFontSize(12);
            doc.setFont(undefined, "bold");
            doc.setTextColor(63, 81, 181); // Indigo color
            doc.text(entry.timestamp, margin, yPosition);
            yPosition += 8;
            doc.setTextColor(0);

            // Language badge if exists
            if (entry.language) {
              const langInfo = getLanguageInfo(entry.language);
              doc.setFontSize(8);
              doc.setFont(undefined, "normal");
              doc.text(`${langInfo.flag} ${langInfo.name}`, margin, yPosition);
              yPosition += 6;
            }

            // Tags if exist
            if (entry.tags && entry.tags.length > 0) {
              doc.setFontSize(8);
              doc.setTextColor(100);
              doc.text(`Tags: ${entry.tags.join(", ")}`, margin, yPosition);
              yPosition += 6;
              doc.setTextColor(0);
            }

            // Entry text
            doc.setFontSize(10);
            doc.setFont(undefined, "normal");
            const lines = doc.splitTextToSize(entry.text, maxWidth);

            lines.forEach((line) => {
              // Check if we need a new page for this line
              if (yPosition > pageHeight - 20) {
                doc.addPage();
                yPosition = margin;
              }
              doc.text(line, margin, yPosition);
              yPosition += 6;
            });

            // Image count if exists
            if (entry.images && entry.images.length > 0) {
              yPosition += 3;
              doc.setFontSize(8);
              doc.setTextColor(150);
              doc.text(
                `ğŸ“· ${entry.images.length} image(s) attached`,
                margin,
                yPosition
              );
              yPosition += 5;
              doc.setTextColor(0);
            }

            // Separator
            yPosition += 5;
            doc.setDrawColor(200);
            doc.line(margin, yPosition, pageWidth - margin, yPosition);
            yPosition += 10;
          });

          // Save the PDF
          doc.save(`journal-export-${Date.now()}.pdf`);
          showMessage(
            `PDF exported! ${entries.length} entries included ğŸ“„`,
            "success"
          );
        } catch (error) {
          console.error("PDF export error:", error);
          showMessage("Error generating PDF. Please try again.", "error");
        }
      }

      function downloadAsFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // ========== EVENT LISTENERS ==========
      document.getElementById("newEntryBtn").addEventListener("click", () => {
        clearTagFilters(); // ğŸ·ï¸ Phase 5.3: Clear tag filters when creating new entry
        setView("new");
        closeMoreMenu();
      });
      document
        .getElementById("viewEntriesBtn")
        .addEventListener("click", () => {
          setView("list");
          closeMoreMenu();
        });

      // More menu items
      document.getElementById("booksMenuBtn").addEventListener("click", () => {
        setView("books");
        closeMoreMenu();
      });
      document.getElementById("tagsMenuBtn").addEventListener("click", () => {
        setView("tags");
        closeMoreMenu();
      });
      document.getElementById("exportMenuBtn").addEventListener("click", () => {
        closeMoreMenu();
        // Trigger export dialog
        const choice = prompt(
          "âš ï¸ SECURITY WARNING âš ï¸\n\n" +
            "Exporting will create an UNENCRYPTED copy of your journal.\n" +
            "Only export if you understand this risk.\n\n" +
            "Choose export format:\n" +
            "â€¢ Type 'PDF' for formatted PDF document\n" +
            "â€¢ Type 'MD' for Markdown text file\n" +
            "â€¢ Type 'CANCEL' or leave blank to exit safely\n\n" +
            "What would you like to do?"
        );

        if (!choice || choice.trim() === "") {
          showMessage("Export cancelled", "info");
          return;
        }

        const normalizedChoice = choice.trim().toUpperCase();

        if (normalizedChoice === "PDF") {
          exportAllToPDF();
        } else if (
          normalizedChoice === "MD" ||
          normalizedChoice === "MARKDOWN"
        ) {
          exportAllToMarkdown();
        } else if (normalizedChoice === "CANCEL") {
          showMessage("Export cancelled", "info");
        } else {
          showMessage("Invalid choice. Export cancelled.", "info");
        }
      });

      document
        .getElementById("themeToggle")
        .addEventListener("click", toggleTheme);

      const signOutBtn = document.getElementById("signOutBtn");
      if (signOutBtn) {
        signOutBtn.addEventListener("click", () => {
          closeMoreMenu();
          signOut();
        });
      }

      // ========== INITIALIZATION ==========
      window.onload = () => {
        applySavedTheme();

        // Apply saved UI language
        const savedLang = localStorage.getItem("uiLanguage") || "en";
        UI_LANGUAGE = savedLang;
        document.getElementById("languageSwitcher").value = savedLang;
        changeUILanguage(savedLang);

        // ğŸ”Œ Setup connection status monitoring
        updateConnectionStatus();
        window.addEventListener("online", updateConnectionStatus);
        window.addEventListener("offline", updateConnectionStatus);

        checkExistingAuth();
      };

      /**
       * Updates the connection status indicator
       */
      function updateConnectionStatus() {
        const statusEl = document.getElementById("connectionStatus");
        const iconEl = document.getElementById("connectionIcon");
        const textEl = document.getElementById("connectionText");

        if (!statusEl) return;

        if (navigator.onLine) {
          statusEl.classList.remove("hidden");
          statusEl.className =
            "px-2 sm:px-3 py-2 rounded-lg text-xs sm:text-sm font-medium bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300";
          iconEl.textContent = "ğŸŸ¢";
          textEl.textContent = "Online";
        } else {
          statusEl.classList.remove("hidden");
          statusEl.className =
            "px-2 sm:px-3 py-2 rounded-lg text-xs sm:text-sm font-medium bg-orange-100 dark:bg-orange-900 text-orange-700 dark:text-orange-300";
          iconEl.textContent = "ğŸ”´";
          textEl.textContent = "Offline";
          showMessage("You are offline. Data will be stored locally.", "info");
        }
      }
      
      // ğŸ“± Register Service Worker for PWA support
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/journal/sw.js')
            .then(registration => {
              console.log('âœ… Service Worker registered successfully:', registration.scope);
            })
            .catch(error => {
              console.log('âŒ Service Worker registration failed:', error);
            });
        });
      }
    </script>
  </body>
</html>
